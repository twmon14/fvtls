%% 
%% Copyright 2019-2021 Elsevier Ltd
%% 
%% This file is part of the 'CAS Bundle'.
%% --------------------------------------
%% 
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%% 
%% The list of all files belonging to the 'CAS Bundle' is
%% given in the file `manifest.txt'.
%% 
%% Template article for cas-dc documentclass for 
%% double column output.

\documentclass[a4paper,fleqn]{cas-dc}
\usepackage{tabularx}
% \usepackage{subtable}

% If the frontmatter runs over more than one page
% use the longmktitle option.

%\documentclass[a4paper,fleqn,longmktitle]{cas-dc}

\usepackage[numbers]{natbib}
%\usepackage[authoryear]{natbib}
% \usepackage[authoryear,longnamesfirst]{natbib}

%%%Author macros
\def\tsc#1{\csdef{#1}{\textsc{\lowercase{#1}}\xspace}}
\tsc{WGM}
\tsc{QE}
%%%

% Uncomment and use as if needed
%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}[theorem]{Lemma}
%\newdefinition{rmk}{Remark}
%\newproof{pf}{Proof}
%\newproof{pot}{Proof of Theorem \ref{thm}}

\begin{document}

\let\WriteBookmarks\relax
\def\floatpagepagefraction{1}
\def\textpagefraction{.001}

% Short title
\shorttitle{TLS 1.0 handshake protocol formal verification case study}    

% Short author
\shortauthors{Thet Wai Mon, Duong Dinh Tran, Adrian Riesco and Kazuhiro Ogata}  

% Main title of the paper
\title [mode = title]{TLS 1.0 handshake protocol formal verification case study: \\an approach to use of CiMPG and CiMPA for existing large proof scores in CafeOBJ}  

% Title footnote mark
% eg: \tnotemark[1]
\tnotemark[1] 

% Title footnote 1.
% eg: \tnotetext[1]{Title footnote text}
\tnotetext[1]{This work was partially supported by ...} 

% First author
%
% Options: Use if required
% eg: \author[1,3]{Author Name}[type=editor,
%       style=chinese,
%       auid=000,
%       bioid=1,
%       prefix=Sir,
%       orcid=0000-0000-0000-0000,
%       facebook=<facebook id>,
%       twitter=<twitter id>,
%       linkedin=<linkedin id>,
%       gplus=<gplus id>]

% \author[<aff no>]{<author name>}[<options>]
\author[1]{Thet Wai Mon}
% Corresponding author indication
% \cormark[<corr mark no>]

% Footnote of the first author
% \fnmark[<footnote mark no>]

% Email id of the first author
\ead{thetwaimon@jaist.ac.jp}

% URL of the first author
% \ead[url]{<URL>}

% Credit authorship
% eg: \credit{Conceptualization of this study, Methodology, Software}
% \credit{<Credit authorship details>}

% Address/affiliation
\affiliation[1]{organization={School of Information Science, Japan Advanced Institute of Science and Technology (JAIST)},
            addressline={1-1 Asahidai}, 
            city={Nomi},
            postcode={923-1292}, 
            state={Ishikawa},
            country={Japan}}

\author[1]{Duong Dinh Tran}

% Footnote of the second author
% \fnmark[2]

% Email id of the second author
\ead{duongtd@jaist.ac.jp}

\author[2]{Adri{\'{a}}n Riesco}
\ead{ariesco@fdi.ucm.es}
\affiliation[2]{organization={Facultad de Inform{\'{a}}tica, Universidad Complutense de Madrid},
            country={Spain}}
            
% URL of the second author
% \ead[url]{}

% Credit authorship
% \credit{}

\author[1]{Kazuhiro Ogata}

% Footnote of the author
\fnmark[*]

% Email id of the author
\ead{ogata@jaist.ac.jp}

% Address/affiliation
% \affiliation[<aff no>]{organization={},
%             addressline={}, 
%             city={},
% %          citysep={}, % Uncomment if no comma needed between city and postcode
%             postcode={}, 
%             state={},
%             country={}}
% \affiliation[1]{organization={School of Information Science, Japan Advanced Institute of Science and Technology (JAIST)},
%             addressline={1-1 Asahidai }, 
%             city={Nomi},
%             postcode={923-1292}, 
%             state={Ishikawa},
%             country={Japan}}
            
% Corresponding author text
% \cortext[1]{Corresponding author}
% \cortext[2]{Corresponding author}
% Footnote text
\fntext[1]{}

% For a title note without a number/mark
%\nonumnote{}
\maketitle

% Here goes the abstract
\begin{abstract}
TLS 1.0 has been formally verified with CafeInMade Proof Generator (CiMPG) and Proof Assistant (CiMPA), where CafeInMaude is the world's second implementation of CafeOBJ, a direct successor of OJB3, the best-known algebraic specification language. The properties concerned are the secrecy property of pre-master secrets and the correspondence (or authentication) property from both master and client points of view. We need to use several lemmas to formally verify that TLS 1.0 enjoys the properties. CiMPG takes proof scores written in CafeOBJ and generate proof scripts that can be checked by CiMPA. Proof scores are subject to human errors and CiMPG can be regarded as a proof score checker in that if the proof scripts generated by CiMPG from proof scores are successfully checked by CiMPA, it is guaranteed that no human error is lurking in the proof scores. We have used the existing proof scores that TLS 1.0 enjoys the two properties. We needed to revise the proof scores so that CiMPG can handle them. CiMPG made us notice that one lemma was missing, namely that a human error was found by CiMPG. There are about 20 proof scores and each proof score is large. It is not reasonable to handle all proof scores at the same time with CiMPG. Thus, we handled each proof score one by one with CiMPG. There is one proof score it took a long time to handle with CiMPG. For the proof score, we handled each induction case one by one to reduce the time taken. We describe how to revise the existing proof scores, how to find the missing lemma, the lemma, how to handle each proof score one by one, and how to handle each induction case one by one as tips on handling existing large proof scores.
\end{abstract}

% Use if graphical abstract is present
%\begin{graphicalabstract}
%\includegraphics{}
%\end{graphicalabstract}

% Research highlights
% \begin{highlights}
% \item 
% \item 
% \item 
% \end{highlights}

% Keywords
% Each keyword is seperated by \sep
\begin{keywords}
 CiMPG \ CafeInMaude \ invariant \ OTS \ proof scores
\end{keywords}

% Main text
\section{Introduction}\label{intro}
Internet security is extremely crucial nowadays because many kinds of credential information, such as credit card numbers and social security numbers, are transmitted over the Internet. To make such transmission secure, many security protocols have been designed and developed so far. One of the most widely used ones is Transport Layer Security (TLS) \cite{dierk} that is the successor of Secure Sockets Layer (SSL) \cite{*1}. 
% here

TLS consists of multiple sub-protocols one of which is the handshake protocol. The handshake protocol is an authentication protocol, allowing a server and a client to authenticate each other and to securely exchange some security parameters. We suppose that each of servers and clients has been securely given a public-private key pair in this paper. As other authentication protocols, several formal verification case studies \cite{article, 10.1145/3133956.3134063, 10.1145/967900.968063} have been conducted so far. Ogata and Futatsugi \cite{1437139} have formally verified that TLS 1.0 handshake protocol enjoys some desired properties by writing proof scores \cite{OgataF03fmoods} in CafeOJB \cite{DiaconescuF98amast} and executing them with CafeOBJ. 
CafeOBJ is a direct successor of OBJ3, the best-known algebraic specification language, and its system is also referred to as CafeOBJ. Proof scores are proof plans written in an algebraic specification language, such as OBJ3 and CafeOBJ.

Proof scores are to be written by human users and what can be done by CafeOBJ for proof scores is to reduce terms. If each term in proof scores reduces as expected, such as to true, which is supposed to be checked by human users, the formal verification concerned is done. Thus, proof scores are subject to human errors, which cannot be checked by CafeOBJ as just mentioned. To address the issue, Riesco and Ogata \cite{RiescoO18tosem} have developed CafeInMaude Proof Generator (CiMPG) and Proof Assistant (CiMPA), where CafeInMaude is the world's second implementation of CafeOBJ in Maude, which is a sibling language of CafeOBJ. CiMPG takes proof scores and generate proof scripts that can be checked by CiMPA, a proof assistant for CafeOBJ. If the proof script generated by CiMPG from proof scores are successfully checked by CiMPA, we can conclude that proof scores are correct and do not have any human errors. CafeOBJ has been used to formally specify and verify several security protocols \cite{10.5555/1765533.1765569, 10.5555/646542.696196, 1357944, 1437139}. However, not all proof scores as they are can be handled by CiMPG. While conducting formal verification with CiMPG can guarantee the reliability even though it is quite strict to tackle. This is because some specific types of case splitting, such as case splitting based on constructors, are permitted in proof scores that can be handled by CiMPG. Some different types, such as case splitting based on semantics, are used in those existing proof scores. To utilize the existing proof scores for CiMPG and CiMPA, we need to learn what and how we should do for the existing proof scores. Furthermore, because those existing proof scores are large, it may take an unreasonable amount of time to handle such large proof scores with CiMPG, we need to come up with how to tackle the issue. We would like to check if the proof scores are correct with CiMPG and CiMPA as well. To this end, we take the proof scores developed for TLS 1.0 handshake protocol \cite{1437139}. This is why we use TLS 1.0 but neither TLS 1.2 nor 1.3 in the present paper. TLS 1.0 handshake protocol is referred to as TLS in the rest of the paper.

CiMPG and CiMPA have been used to formally verify laboratory authentication protocols, such as NSLPK (Needham-Schroeder-Lowe Public Key) for the nonce secrecy property \cite{RiescoO18tosem}, IFF (Identity-Friend-or-Foe) for the identifiable property \cite{twmon} and NSLPK for the correspondence property as well as the nonce secrecy property \cite{twmon}. We are the first who have formally verify TLS with CiMPG and CiMPA.

A network in the formal specification of TLS is formalized as a soup of messages, where a soup is an associative-commutative collection. Let \verb|_,_| be the constructor of non-empty soups. Let us consider a case splitting as follows: a case is split into two subcases: (1) there is a specific message $m$ in the network and (2) there is no such a message in the network. (1) can be characterized by the equation \verb!eq nw(s) = m , nw .!, while (2) can be expressed by the equation \verb!eq m \in nw(s) = false.! \verb!nw(s)! denotes the network (the soup of messages) in a given state $s$ and \verb!nw! denotes an arbitrary network. The first equation says that \verb!nw(s)! equals \verb!m , nw!, and then there exists \verb!m in nw(s)!. \verb|_\in_| is the membership predicate for soups and the second equation says that there does not exist in \verb!nw(s)!. Hence, the case splitting is semantically correct. However, the case splitting cannot be handled by CiMPG. The first equation should be revised as follows: 
\verb!eq m \in nw(s) = true!. CiMPG found one missing lemma, meaning that the existing proof scores for TLS had a human error. It took too much time to handle all proof scores at the same with CiMPG. Thus, we need to tackle each proof score one by one. To this end, we are supposed to provide all needed lemmas for the proof scores. Because all lemmas except for one are given, we know what lemmas are needed for each proof score in advance. There is one proof score such that even if we handle the proof score only with CiMPG, it took an unreasonable amount of time to do so. Therefore, we handle each induction case one by one for the proof score, reducing the time taken to the proof script with CiMPG. Note that the main proof technique used is (simultaneous) structural induction on reachable states. We describe how to revise the existing proof scores, how to find the missing lemma, the lemma, how to handle each proof score one by one, and how to handle each induction case one by one as tips on handling existing large proof scores.

% You should summarize the main contributions here in Introduction. But I do not clearly know the main contributions now and then cannot give you very concrete candidates.

The rest of the paper is organized as follows. Section \ref{pre} gives some preliminaries by using a small example. Section \ref{tls} describes TLS 1.0 handshake protocol and the abstract version of the protocol. Section \ref{fstls} presents the formal specification and the properties of TLS handshake protocol.
Section \ref{revision} describes how to revise the existing proof scores and one missing lemma. Section \ref{fvtls} discusses a way to use CiMPG for existing large proof scores in formal verification. Some related work is mentioned in Section \ref{relatedwork}. Finally, Section \ref{conclusion} contains our
conclusions 
% and outlines some lines of future work. 
The formal specification, the revised proof scores and the proof scripts generated by CiMPG of the protocol are available on GitHub \footnote{\url{https://github.com/twmon14/fvtlscimpg}}.

% As written, the formal verification is too weak as the main contributions. You need to have at least one section that is dedicated to the main contributions.

\section{Preliminaries}\label{pre}
% Please make one section that is dedicated to Preliminaries where you are supposed to describe CafeOBJ (or CafeInMaude), proof socres, CiMPG, proof script and CiMPA by using a small example, such as IFF.
This section gives some common notions and background which are requirements for the paper. We first present the CafeOBJ specification and proof scores through a simple example such as IFF protocol. We then describe CafeInMaude, how to use CiMPA for proving the properties of the example and how CiMPG is used to generate proof scripts from proof scores.
% infers the proof score.
% We present in this section some preliminaries such as
% CafeOBJ specification of the IFF protocol, how to prove properties on this protocol by using proof scores. Then we show CafeInMaude, how to use CiMPA for proving the properties of the example and how CiMPG infers the proof script.

\subsection{CafeOBJ} \label{cafeobj}
CafeOBJ \cite{DiaconescuF98amast} is a direct successor of OBJ3, a formal specification language in which formal verification is conducted by writing what is called "proof scores" \cite{OgataF03fmoods} and executing them with CafeOBJ. CafeOBJ implements equational logic by rewriting and provides several features such as flexible mix-fix syntax, parameterized modules and views for instantiating the parameters, module expressions, operators for defining terms, equations for defining the equalities as rewrite rules, and transitions for specifying how a system evolves, etc. Proof scores consist of the reduction, by means of equations, of goal-oriented terms in user-defined modules (the so-called open–close environments), and checking whether they are reduced to the expected value (usually true). 
% More specifically, given a property that must hold in an initial module, we have that:
% —These goal-oriented terms must take into account whether (i) we require induction and
% hence a ground term built with constructors should substitute some of the variables from
% the goal while the rest should be substituted by fresh constants; or (ii) we need to use any
% of the hypotheses, probably by using an implication.
% —These user-defined modules must include the definitions for all fresh constants required
% by the equations and the equations standing for the hypotheses or case splittings, among
% others.

\subsection{IFF in CafeOBJ}
IFF (Identify-Friend-or-Foe) \cite{iff2001} is used to check if a principal is a member of a group. The IFF protocol can be described as the following two message exchanges:
	
	${\rm Check} \ \ \: p \rightarrow q : r$
	
	${\rm Reply}  \ \ \ q \rightarrow p : \varepsilon_k(r,q)$
	
	\noindent
Each principal (or agent) such as $p$ and $q$ belongs to only one group. A symmetric key is given to each group, whose members share the same key, and keys are different from group to group. If a principal $p$ wants to check if a principal $q$ is a member of the $p$'s group, $p$ generates a fresh random number $r$ and sends it to $q$ as a $\rm Check$ message. 
On receipt of the $\rm Check$ message, $q$ sends back to $p$ a $\rm Reply$ message that consists of $r$ and ID $q$ encrypted by the symmetric key $k$ of the $q$'s group. On receipt of the $\rm Reply$ message, $p$ tries to decrypt the ciphertext with the symmetric key of the $p$'s group. If the decryption succeeds and the plaintext consists of $r$ and $q$, $p$ then concludes that $q$ is a member of the $p$'s group. 
	%The protocol is supposed to have the property that if $p$ receives a valid $\rm Reply$ message from $q$, $q$ is always a member of the $p$'s group. The property is called the IFF property in this paper.
	
We suppose that the cryptosystem used is perfect, there are an arbitrary number of principles for which sort Prin is declared. There is only one legitimate group, all members of the group are trustable, and there are also untrustable principals who are not members. There is one special principal, an intruder, that is expressed as constant enemy of Prin. Trustable principals exactly follow the protocol, but untrustable ones may do something against the protocol as well. 
% The combination and cooperation of untrustable principals is modeled as the most general enemy (or intruder). 
The enemy gleans as much information as possible from messages flowing in the network and creates the fake messages based on the gleaned information, provided that the enemy cannot break the perfect cryptosystem.
We first declare the operator \verb!enc! to specify the ciphertexts which consists of three parameters such as the key, the random number and the principal.
% \begin{small}
% \begin{verbatim}
% 		op enc : Key Rand Prin -> Cipher . op k : Cipher -> Key .
% 		op r : Cipher -> Rand . op p : Cipher -> Prin .
% 		\end{verbatim}
% \end{small}
% 	\smallskip
% \noindent
% where \verb!Key! is the sort (or type) representing symmetric keys, \verb!Rand! is the sort denoting random numbers, \verb!Prin! is the sort representing principals, and \verb!Cipher! is the sort denoting ciphertexts. 
\verb!enc!$(k,r,p)$ denotes the ciphertext obtained by encrypting a random number $r$ and a principal $p$ with a key $k$. 
% Operators \verb!k!, \verb!r! and \verb!p! return the first, second and third arguments of \verb!enc!$(k, r, p)$, respectively.
Two messages, $\rm Check$ and $\rm Reply$ are specified by two operators \verb!cm! and \verb!rm!.
% as follows:
% 	\begin{small}
% 		\begin{verbatim}
% 			op cm : Prin Prin Prin Rand   -> Msg
% 			op rm : Prin Prin Prin Cipher -> Msg
% 		\end{verbatim}
% 	\end{small}
% 	%constant enemy denotes the enemy,
% 	\noindent
% where \verb!Msg! is the sort denoting messages.
The first, second and third arguments of each of \verb!cm! and \verb!rm! are the actual creator, the seeming sender and the receiver of the corresponding message. The first argument is meta-information that is only available to the outside observer and that cannot be forged by the enemy; while the remaining arguments may be forged by the enemy. 
	
The network is modeled as a multiset of messages. Any message that has been sent or put once into the network is supposed to be never deleted from the network because the enemy can replay the message repeatedly, although the enemy cannot forge the first argument. Consequently, the empty network (i.e., the empty multiset) means that no messages have been sent. The enemy tries to glean two kinds of values from the network, which are random numbers and ciphertexts. The collections of these values gleaned by the enemy are denoted by operators \verb!rands! and \verb!ciphers!.
% , which are declared as follows:
% 	\begin{small}
% 		\begin{verbatim}
% 			op rands   : Network -> ColRands
% 			op ciphers : Network -> ColCiphers
% 		\end{verbatim}
% 	\end{small}
% 	\noindent
% 	where \verb!Network! is the sort denoting networks, \verb!ColRands! is the sort denoting collections of random numbers, and \verb!ColCiphers! is the sort denoting collections of ciphertexts. 
% 	\verb!ciphers! is defined by the following equations:
% 	\begin{small}
% 		\begin{verbatim}
% 			eq C \in ciphers(void) = false .
% 			ceq C \in ciphers(M , NW) = true if rm?(M) and C = c(M) .
% 			ceq C \in ciphers(M , NW) = C \in ciphers(NW) 
% 			if not(rm?(M) and C = c(M)) .
% 		\end{verbatim}
% 	\end{small}
% 	\noindent
% 	where \verb!void! denotes the empty multiset (or empty network),
% 	operator \verb!rm?! checks if a given message is a $\rm Reply$ message,
% 	operator \verb!c! takes a $\rm Reply$ message as a parameter and returns its ciphertext (i.e., the fourth argument of \verb!rm! operator),
% 	\verb!\in! is an infix operator checking the existence of an element in a collection,
% 	and operator \verb!,! in \verb!M , NW! denotes the data constructor of nonempty multisets. 
% 	The equations say that a ciphertext \verb!C! is available to the enemy iff there exists a $\rm Reply$ message whose content is \verb!C!. \verb!rands! can be defined likewise.
We use two observational functions \verb!nw! and \verb!ur! to observe the network and the set of used random numbers.
% , respectively as follows:
% 	\begin{small}
% 	\begin{verbatim}
% 		op nw : Sys -> Network . op ur : Sys -> URands
% 		\end{verbatim}
% 	\end{small}
% 	\noindent
% 	where \verb!Sys! is the sort denoting the state space of IFF, \verb!URands! is the sort denoting the sets of random numbers.
and five transitions together with one constant of \verb!Sys! to represent an arbitrary initial state.
% as follows: 
% 	\begin{small}
% 		\begin{verbatim}
% 			op init  : -> Sys {constr}
% 			op sdcm  : Sys Prin Prin Rand -> Sys {constr}
% 			op sdrm  : Sys Prin Msg -> Sys {constr}
% 			op fkcm1 : Sys Prin Prin Rand -> Sys {constr}
% 			op fkrm1 : Sys Prin Prin Cipher -> Sys {constr}
% 			op fkrm2 : Sys Prin Prin Rand -> Sys {constr}
% 		\end{verbatim}
% 	\end{small}
% 	\noindent
Among five transitions, \verb!sdcm! and \verb!sdrm! formalize sending $\rm Check$ and $\rm Reply$ messages. The remaining actions \verb!fkcm1!, \verb!fkrm1!, and \verb!fkrm2! are the enemy's faking messages.
% , which can be understood as follows:
% 	\begin{itemize}
% 		\item \verb!fkcm1!: a random number \verb!R! is available to the enemy, the enemy fakes and sends a $\rm Check$ message using \verb!R!, 
% 		\item \verb!fkrm1!: a ciphertext \verb!C! is available to the enemy, the enemy fakes and sends a $\rm Reply$ message using \verb!C!, 
% 		\item \verb!fkrm2!: a random number \verb!R! is available to the enemy, the enemy fakes and sends a $\rm Reply$ message using \verb!R!.
% 	\end{itemize}
% 	\verb!sdcm! is defined as follows:
% 	\begin{small}
% 		\begin{verbatim}
% 			ceq nw(sdcm(S,P1,P2,R)) = (cm(P1,P1,P2,R) ,
% 			nw(S)) if c-sdcm(S,P1,P2,R) .
% 			ceq ur(sdcm(S,P1,P2,R)) = (R ur(S))
% 			if c-sdcm(S,P1,P2,R) .
% 			ceq sdcm(S,P1,P2,R) = S 
% 			if not c-sdcm(S,P1,P2,R) .
% 		\end{verbatim}
% 	\end{small}
% 	\noindent
% 	where \verb!c-sdcm(S,P1,P2,R)! is \verb!not(R \in ur(S))!.
% 	The equations say that if \verb!c-sdcm(S,P1,P2,R)! is true (i.e., \verb!R! has not been used), then the $\rm Check$ message \verb!cm(P1,P1,P2,R)! is put into the network \verb!nw(S)!, \verb!R! is put into \verb!ur(S)! in the state denoted by \verb!sdcm(S,P1,P2,R)!; if \verb!c-sdcm(S,P1,P2,R)! is false, nothing changes. 
% \noindent
The operators are defined with equations. \verb!fkrm1! is defined as follows:
% \begin{small}
\begin{verbatim}
op c-fkrm1 : Sys Prin Prin Cipher -> Bool
eq c-fkrm1(S,P1,P2,C) = C \in ciphers(nw(S)) .
ceq nw(fkrm1(S,P1,P2,C)) = rm(enemy,P1,P2,C) , nw(S) 
if c-fkrm1(S,P1,P2,C) .
eq ur(fkrm1(S,P1,P2,C))  = ur(S) .
ceq fkrm1(S,P1,P2,C) = S if not c-fkrm1(S,P1,P2,C) .
\end{verbatim}
% \end{small}
\noindent
where \verb!c-fkrm1(S,P1,P2,C)! is \verb!C \in! \verb!ciphers(nw(S))!, 
\verb!enemy! is a constant of \verb!Prin! denoting an arbitrary enemy.
The equations say that if \verb!c-fkrm1(S,P1,P2,R)! is true, then the $\rm Reply$ message \verb!rm(enemy,P1,P2,C)! is put into the network \verb!nw(S)!, \verb!ur(S)! does not change in the state denoted by \verb!fkrm1(S,P1,P2,C)!; if \verb!c-fkrm1(S,P1,P2,C)! is false, nothing changes. 
% The remaining transitions can be defined likewise.
% --here	
% In order to specify this protocol in CafeOBJ, we first define the module PRINCIPAL, which starts by mod! to indicate that it has tight semantics. This module defines the sort Prin and indicates the enemy (denoted by the constr attribute). It also defines an equation for the equality predicate meaning that only syntactically equal term is equal.
% \begin{small}
% \begin{verbatim}
% mod! PRINCIPAL {
%   [Prin]
%   op enemy : -> Prin {constr}   eq (P:Prin = P) = true .
% }
% \end{verbatim}
% \end{small}
% The below module KEY defines the sort Key and indicates the symmetric key.
% \begin{small}
% \begin{verbatim}
% mod! KEY {
%   pr(PRINCIPAL)
%   [Key]
%   op k : Prin -> Key    op p : Key -> Prin
%   var P : Prin          vars K1 K2 : Key    eq p(k(P)) = P .
%   ceq (K1 = K2) = true if not(p(K1) = enemy) and not(p(K2) = enemy) .
%   ceq (K1 = K2) = false if not(p(K1) = enemy) and p(K2) = enemy .
% }
% \end{verbatim}
% \end{small}
% The operator k is a function that returns the key of a given principal based on that principal. Similarly, the operator p is a function that returns the principal holding the key based on the key.
% The module RAND is defined as follows:
% \begin{small}
% \begin{verbatim}
% mod! RAND {
%   [Rand]
%   op _=_ : Rand Rand -> Bool {comm}
% }
% \end{verbatim}
% \end{small}
% The operation \_=\_ is a equality predicate to determine whether the terms representing two random numbers are equal.
% The specification of cipher text is defined as follows:
% \begin{small}
% \begin{verbatim}
% mod! CIPHER {
%   pr(PRINCIPAL + KEY + RAND)
%   [Cipher]
%   op enc : Key Rand Prin -> Cipher  op k : Cipher -> Key
%   op r : Cipher -> Rand             op p : Cipher -> Prin
%   var K : Key   var R : Rand var P : Prin  vars C1 C2 : Cipher
%   eq k(enc(K,R,P)) = K . eq r(enc(K,R,P)) = R .eq p(enc(K,R,P)) = P .
%   eq (C1 = C2) = (k(C1) = k(C2) and r(C1) = r(C2) and p(C1) = p(C2)) .
% }
% \end{verbatim}
% \end{small}
% The module defines the ciphertext enc which consists of three parameters such as Key, Rand and Prin. Given the key, the random number and the principal, it represents the ciphertext enc(K,R,P). The operators k, r and p return the first, second and third parameters of the operator enc, respectively.
% The module MSG defines the two exchanged messages with the sort Msg.
% \begin{small}
% \begin{verbatim}
% mod! MSG {
%   pr(PRINCIPAL + RAND + CIPHER)
%   [Msg]
%   --      creator source destination body
%   --      ---------------------------------
%   op cm : Prin    Prin   Prin        Rand   -> Msg
%   op rm : Prin    Prin   Prin        Cipher -> Msg
%   op cm? : Msg -> Bool  op rm? : Msg -> Bool
%   op crt : Msg -> Prin  op src : Msg -> Prin
%   op dst : Msg -> Prin  op r : Msg -> Rand op c : Msg -> Cipher
%   vars P1 P2 P3 : Prin  var R : Rand  var C : Cipher
%   vars M1 M2 : Msg
%   eq cm?(cm(P1,P2,P3,R)) = true . eq cm?(rm(P1,P2,P3,C)) = false .
%   eq rm?(cm(P1,P2,P3,R)) = false . eq rm?(rm(P1,P2,P3,C)) = true .
%   eq crt(cm(P1,P2,P3,R)) = P1 . eq crt(rm(P1,P2,P3,C)) = P1 .
%   eq src(cm(P1,P2,P3,R)) = P2 . eq src(rm(P1,P2,P3,C)) = P2 .
%   eq dst(cm(P1,P2,P3,R)) = P3 . eq dst(rm(P1,P2,P3,C)) = P3 .
%   eq r(cm(P1,P2,P3,R)) = R .    eq c(rm(P1,P2,P3,C)) = C .
%   ceq (M1 = M2) = (cm?(M1) and crt(M1) = crt(M2) and src(M1) = src(M2)
%   and dst(M1) = dst(M2) and r(M1) = r(M2)) if cm?(M2) .
%   ceq (M1 = M2) = (rm?(M1) and crt(M1) = crt(M2) and src(M1) = src(M2)
%   and dst(M1) = dst(M2) and c(M1) = c(M2)) if rm?(M2) .
% }
% \end{verbatim}
% \end{small}
% The operator cm takes three principals and a random number as parameters and return a message. Similarly, the operator rm takes three principals and a ciphertext as parameters and return a message. First three parameters in each message represents the actual creator, seeming sender and receiver of the message and the operators crt, src and dst return the first, second and third parameters, respectively. The operators cm? and rm? are predicates that determine whether the given message is cm or rm. The operators r and s return a random number and a ciphertext from the given message, respectively.
% The module TRIV below states the existence of the principal sort Elt which
% stands for elements and it has equality predicates.
% \begin{small}
% \begin{verbatim}
% mod* TRIV principal-sort Elt {
% [Elt]
% op _=_ : Elt Elt -> Bool {comm} eq (E:Elt = E) = true .
% }
% \end{verbatim}
% \end{small}
% The module BAG is parameterized by the module TRIV; thus, it defines a bag (multiset) of any sort fulfilling the requirements above. Elt.D stands for the sort Elt from the parameter D, which is required to fulfill the requirements from module TRIV (stated with syntax D :: TRIV) and a supersort Bag containing elements. Then, appropriate operators are defined:
% \begin{small}
% \begin{verbatim}
% mod! BAG (D :: TRIV) {
%   [Elt.D < Bag]
%   op void : -> Bag
%   op _,_ : Bag Bag -> Bag { assoc comm id: void }
%   op _\in_ : Elt.D Bag -> Bool
%   var B : Bag   vars E1 E2 : Elt.D
%   eq E1 \in void = false .
%   ceq E1 \in (E2,B) = true if E1 = E2 .
%   ceq E1 \in (E2,B) = E1 \in B if not(E1 = E2) .
% }
% \end{verbatim}
% \end{small}
% where \verb!void! denotes the empty multiset, \verb!\in! is an infix operator checking the existence of an element in a bag, and operator \verb!,! denotes the data constructor of nonempty multisets. Similarly, the parameterized modules SET and COLLECTION are aslo defined as follows:
% \begin{small}
% \begin{verbatim}
% mod! SET (D :: TRIV) {
%   [Elt.D < Set]
%   op empty : -> Set
%   op __ : Set Set -> Set { assoc comm idem id: empty }
%   op _\in_ : Elt.D Set -> Bool
%   var S : Set   vars E1 E2 : Elt.D
%   eq E1 \in empty = false .
%   ceq E1 \in (E2 S) = true if E1 = E2 .
%   ceq E1 \in (E2 S) = E1 \in S if not(E1 = E2) .
% }
% \end{verbatim}
% \end{small}
% \begin{small}
% \begin{verbatim}
% mod! COLLECTION(D :: TRIV) {
%   [Elt.D < Col]
%   op _\in_ : Elt.D Col -> Bool
% }
% \end{verbatim}
% \end{small}
% We use the views TRIV2MSG, TRIV2CIPHER and TRIV2RAND to indicate that the modules MSG, CIPHER and RAND satisfy the requirements stated by TRIV by using the given mapping:
% \begin{small}
% \begin{verbatim}
% view TRIV2MSG from TRIV to MSG {
%   sort Elt -> Msg
% }
% view TRIV2CIPHER from TRIV to CIPHER {
%   sort Elt -> Cipher
% }
% view TRIV2RAND from TRIV to RAND {
%   sort Elt -> Rand
% }
% \end{verbatim}
% \end{small}
% The network is modeled as a bag of messages. 
% It first imports the modules with their parameters instantiated by TRIV2MSG, TRIV2RAND and TRIV2CIPHER. The sort name has been changed from Bag to Network, from
% Col to ColRands and ColCiphers.
% The functions rands and ciphers return the collection of random numbers that have been used and the collection of nonces gathered by
% the intruder from the network in a given multiset, respectively. Other equations and conditional equations are also defined:
% \begin{small}
% \begin{verbatim}
% mod! NETWORK {
%   pr(BAG(D <= TRIV2MSG)*{ sort Bag -> Network })
%   pr(COLLECTION(D <= TRIV2RAND)*{sort Col -> ColRands})
%   pr(COLLECTION(D <= TRIV2CIPHER)*{sort Col -> ColCiphers})
% --
%   op rands : Network -> ColRands
%   op ciphers : Network -> ColCiphers
% --
%   var NW : Network  var M : Msg var R : Rand    var C : Cipher
% -- rands
%   eq R \in rands(void) = false .
%   ceq R \in rands(M,NW) = true if cm?(M) and R = r(M) .
%   ceq R \in rands(M,NW) = true if rm?(M) and k(enemy) = k(c(M)) 
%   and R = r(c(M)) .
%   ceq R \in rands(M,NW) = R \in rands(NW) if not(cm?(M) and 
%   R = r(M)) and not(rm?(M) and k(enemy) = k(c(M)) 
%   and R = r(c(M))) .
% -- ciphers
%   eq C \in ciphers(void) = false .
%   ceq C \in ciphers(M,NW) = true if rm?(M) and C = c(M) .
%   ceq C \in ciphers(M,NW) = C \in ciphers(NW) if not(rm?(M) 
%   and C = c(M)) .
% }
% \end{verbatim}
% \end{small}
% Finally, the module IFF specifies the behavior of the protocol as an observational transition system \cite{OgataF03fmoods}. It first imports the modules NETWORK and SET with its parameter RAND. The sort name has been changed from Set to URands (used random numbers).
% %  A collection can include different types of elements. Whereas a set is a well-defined collection of distinct elements
% \begin{small}
% \begin{verbatim}
% mod* IFF {
%   pr(NETWORK)   pr(SET(RAND)*{sort Set -> URands})
% \end{verbatim}
% \end{small}  
% The network is modeled as a bag of messages. 
% The sort Sys stands for the state space of the system. The system starts in the init state. We use two observational functions \verb!nw! and \verb!ur! to observe the network and the set of used random numbers, respectively.
% \begin{small}
% \begin{verbatim}
%   [Sys]
% -- an arbitrary initial state
%   op init : -> Sys {constr}
% -- observations
%   op nw : Sys -> Network    op ur : Sys -> URands
% \end{verbatim}
% \end{small}  
% We use five transitions: \verb!sdcm! and \verb!sdrm! formalize sending $\rm Check$ and $\rm Reply$ messages exactly following the protocol.
% The remaining transitions \verb!fkcm1!, \verb!fkrm1!, and \verb!fkrm2! are the enemy's faking messages, respectively.
% \begin{small}
% \begin{verbatim}
%   op sdcm : Sys Prin Prin Rand -> Sys {constr}
%   op sdrm : Sys Prin Msg -> Sys {constr}
%   --
%   op fkcm1 : Sys Prin Prin Rand -> Sys {constr}
%   op fkrm1 : Sys Prin Prin Cipher -> Sys {constr}
%   op fkrm2 : Sys Prin Prin Rand -> Sys {constr}
% \end{verbatim}
% \end{small}
% The observational functions are easily applied to the init state: the network and the set of used random numbers are empty:
% \begin{small}
% \begin{verbatim}
% -- CafeOBJ variables
%   var S : Sys   vars P1 P2 P3 : Prin  vars M1 M2 : Msg
%   var R : Rand  var C : Cipher  var K : Key
% -- for any initial state
%   eq nw(init) = void .  eq ur(init) = empty .
% \end{verbatim}
% \end{small}
% In order to define the behavior of the values observed by these two functions for transition functions, we specify
% an auxiliary condition (or effective condition). For example, \verb!fkrm1! has an auxiliary condition c-fkrm1 that returns true when \verb!C! is in the collection of ciphertexts. Assuming that the condition holds, the equation for nw indicates that, the $\rm Reply$ message \verb!rm(enemy,P1,P2,C)! is put into the network \verb!nw(S)! in the state denoted by \verb!fkrm1(S,P1,P2,C)!; if \verb!c-fkrm1(S,P1,P2,C)! does not hold, nothing changes.
% \verb!sdcm!  c-sdcm that returns true when \verb!R! has not been used. Assuming that the condition holds, the equation for nw and ur indicate that, the $\rm Check$ message \verb!cm(P1,P1,P2,R)! is put into the network \verb!nw(S)! and \verb!R! is put into \verb!ur(S)! in the state denoted by \verb!sdcm(S,P1,P2,R)!; if \verb!c-sdcm(S,P1,P2,R)! does not hold, nothing changes.
% \begin{small}
% \begin{verbatim}
% -- for action fkrm1
%   op c-fkrm1 : Sys Prin Prin Cipher -> Bool
%   eq c-fkrm1(S,P1,P2,C) = C \in ciphers(nw(S)) .
%   ceq nw(fkrm1(S,P1,P2,C)) = rm(enemy,P1,P2,C) , nw(S) 
%   if c-fkrm1(S,P1,P2,C) .
%   eq ur(fkrm1(S,P1,P2,C))  = ur(S) .
%   ceq fkrm1(S,P1,P2,C)     = S  if not c-fkrm1(S,P1,P2,C) .
% \end{verbatim}
% \end{small}
\noindent
The remaining four transitions
% for \verb!sdcm!, \verb!sdrm!, \verb!fkcm1! and \verb!fkrm2! 
can be defined analogously.
We define two invariants in our system. The first ensures identifiable property by stating that whenever $p$ receives a valid $\rm Reply$ message from $q$, $q$ is always a member of the $p$'s group. Note that our goal is just inv1, while inv2 is an auxiliary lemma required for proving inv1.
% \begin{small}
% \begin{verbatim}
% -- declare invariant candidates
%   op inv1 : Sys Prin Prin Prin Key Rand -> Bool
%   op inv2 : Sys Key Rand -> Bool
% -- CafeOBJ variables
%  var S : Sys vars P1 P2 P3 : Prin var K : Key var R : Rand
% -- define invariant candidates
%   eq inv1(S,P1,P2,P3,K,R) = ((not(K = k(enemy)) and rm(P1,P2,P3,
%   enc(K,R,P2)) \in nw(S)) implies not(P2 = enemy)) .
%   eq inv2(S,K,R) = (enc(K,R,enemy) \in ciphers(nw(S)) 
%   implies (K = k(enemy))) .
% }
% \end{verbatim}
% \end{small}
We will present in the following section how we can prove these invariants by using proof scores method in CafeOBJ.

\subsection{Proof Scores for Verifying IFF} \label{pscores}
In this section, we introduce proof scores by proving the invariants above. We will focus on proving the first invariant, inv1, for the base case and inductive case. Since there were five transition functions, the inductive case for inv1 is divided into five cases; proof fragments are created for each case where auxiliary condition holds and does not hold. We describe \verb!fkrm1! among five transition functions. The complete proof is available on GitHub \footnote{\url{https://github.com/twmon14/fvap/tree/main/IFF}}. We first prove the invariant for the base case, init. 
% In this case, our system is init and fresh constants a, b, c, s, k and r1 are declared, respectively.
% \begin{small}
% \begin{verbatim}
% open IFF .
% op a : -> Prin . op b : -> Prin . op c : -> Prin .
% op s : -> Sys .  op k : -> Key .  op r1 : -> Rand .
% red inv1(init,a,b,c,k,r1) .
% close
% \end{verbatim}
% \end{small}
CafeOBJ returns true for the base case. We can define a similar environment for the fkrm1 case. The proof is semantically split into two subcases: (i) c-fkrm1 holds and (ii) c-fkrm1 does not hold. The proof fragment below corresponds to (i): 
% \begin{small}
\begin{verbatim}
open IFF .
ops a b c d e : -> Prin .  op s : -> Sys .    
op r1 : -> Rand .   op r2 : -> Cipher . op k : -> Key .
eq r2 \in ciphers(nw(s)) = true .
red inv1(fkrm1(s,d,e,r2),a,b,c,k,r1) .
close
\end{verbatim}
% \end{small}
% -- c-fkrm1(s,d,e,r2) = true .
however, the term cannot be reduced to true due to the lack of information in the module on the fresh constants whether they are different or not. We need to include this information by means of equations. We put some assumptions in the environment below. More strategies on how to find these case splittings can be found in \cite{OgataF03fmoods, Ogata2006, nakano2003}. Moreover, we use the induction hypothesis as a premise in the reduction command as follows:
\begin{small}
\begin{verbatim}
open IFF .
ops a b c d e : -> Prin .  op s : -> Sys .    
op r1 : -> Rand .   op r2 : -> Cipher . op k : -> Key .
eq r2 \in ciphers(nw(s)) = true . --(1)
eq (rm(enemy,d,e,r2) = rm(a,b,c,enc(k,r1,b))) = false . --(2)
red inv1(s,a,b,c,k,r1) implies inv1(fkrm1(s,d,e,r2),a,b,c,k,r1) .
close
\end{verbatim}
\end{small}
Here, we have proven a very specific case in which an additional equation is used as a assumption. We need to prove all possible cases to really prove the invariant. For example, we can assume that rm(enemy,a,b,r2) is equal to rm(p1,p2,p3,enc(k,r,p2)) as follows: 
\begin{small}
\begin{verbatim}
open IFF .
ops a b c d e : -> Prin .  op s : -> Sys .  
op r1 : -> Rand .   op r2 : -> Cipher . op k : -> Key .
eq enc(k,r1,b) \in ciphers(nw(s)) = true . --(3)
eq a = enemy .  eq d = b .  eq e = c .  eq r2 = enc(k,r1,b) .
eq k = k(enemy) . --(4)
red inv1(s,a,b,c,k,r1) implies inv1(fkrm1(s,d,e,r2),a,b,c,k,r1) .
close
\end{verbatim}
\end{small}
In that case, (1) is semantically rewritten into (3) and (2) is rewritten into four sub-equations. Moreover, the equation (4) is required to use as an assumption. Then, CafeOBJ returns true for this case. The case in which (4) does not hold, however, cannot be reduced into true, In that case, an additional equation \verb!b = enemy! is required to use for case-splitting, the equation (3) is rewritten into \verb!enc(k,r1,enemy) \in ciphers(nw(s)) = true! and moreover, the second invariant, inv2 is used as the induction hypothesis to deduce that.
% \begin{small}
% \begin{verbatim}
% open IFF .
% op a : -> Prin . op b : -> Prin . op c : -> Prin .
% op s : -> Sys .  op k : -> Key .  op r1 : -> Rand .
% op d : -> Prin . op e : -> Prin . op r2 : -> Cipher .
% -- eq r2 \in ciphers(nw(s)) = true .  
% -- eq enc(k,r1,b) \in ciphers(nw(s)) = true . --(2)
% eq enc(k,r1,enermy) \in ciphers(nw(s)) = true . --(2.1)
% -- assumption
% -- eq rm(enemy,d,e,r2) = rm(a,b,c,enc(k,r1,b)) . 
% eq a = enemy .  eq d = b .  eq e = c .  eq r2 = enc(k,r1,b) .
% eq (k = k(enemy)) = false . -- (4)
% eq b = enemy . -- (5)
% red inv2(s,k,r1) implies inv1(s,a,b,c,k,r1) 
% implies inv1(fkrm1(s,d,e,r2),a,b,c,k,r1) .
% close
% \end{verbatim}
% \end{small}
% where the equation (2) is semantically rewritten into (2.1) according to the equation (5). 
When c-fkrm1 does not hold, the assumption eq c-fkrm1(s,d,e,r2) = false is used and CafeoBJ returns true for this case.
% \begin{small}
% \begin{verbatim}
% open IFF .
% op a : -> Prin . op b : -> Prin . op c : -> Prin .
% op s : -> Sys .  op k : -> Key .  op r1 : -> Rand .
% op d : -> Prin . op e : -> Prin . op r2 : -> Cipher .
% eq c-fkrm1(s,d,e,r2) = false .
% red implies inv1(s,a,b,c,k,r1) 
% implies inv1(fkrm1(s,d,e,r2),a,b,c,k,r1) .
% close
% \end{verbatim}
% \end{small}

Similarly, we would write proof scores for covering all cases for all invariant. Note that it is easy to develop proofs with proof scores, but it is also subject to human errors which leads to the case that we would run the complete set of proof scores obtaining true for all of them, but the property would not be really proven.  Unfortunately, the case splittings based on semantics used in the existing proof scores cannot be handled by CiMPG. To utilize CiMPG and CiMPA, 
% we need to revise the the existing proof scores.
% ; how to revise the proof scores will be described in the next section.
% \subsection{Revising semantic-based case splitting in the IFF proof scores} \label{semantic}
% We describe in this section how to revise the existing proof score of IFF to use CiMPG using the previous example, fkrm1.
% In the existing proof scores of IFF, there are many times case splitting based on semantics are used. However, this case splitting cannot be handled by CiMPG although it is correct from proof score point of view. 
thus, we need to revise the proof scores to get rid of any case splitting based on semantics. For example, we have seen that the original proof score for the induction case  \verb!fkrm1! of inv1 consists of semantic-based case splittings; the revised proof score for \verb!fkrm1! contains 11 subcases as shown in Table \ref{fig-cs-inv1iff}.
\noindent
\begin{table}[]
	\begin{tabular}{l|l}
		\hline
		(1.1.1.1.1.1.1.1)   & $c1$, $c2$, $c3$, $c4$, $c5$, $c6$, $c7$, $c8$                                                    
		\\ \hline
		(1.1.1.1.1.1.1.2.1.1)         & $c1$, ..., $\neg c8$, $c9$, $c10$                                                       \\ \hline
		(1.1.1.1.1.1.1.2.1.2)         & $c1$, ..., $\neg c8$, $c9$, $\neg c10$                                                       \\ \hline
		(1.1.1.1.1.1.1.2.2) & $c1$, ..., $\neg c8$, $\neg c9$
		\\ \hline
		(1.1.1.1.1.1.2) & $c1$, $c2$, $c3$, $c4$, $c5$, $c6$, $\neg c7$ \\ \hline
		(1.1.1.1.1.2)   & $c1$, $c2$, $c3$, $c4$, $c5$, $\neg c6$              \\ \hline
		(1.1.1.1.2)     & $c1$, $c2$, $c3$, $c4$, $\neg c5$                           \\ \hline
		(1.1.1.2)       & $c1$, $c2$, $c3$, $\neg c4$                                        \\ \hline
		(1.1.2)       & $c1$, $c2$, $\neg c3$                                        \\ \hline
		
	    (1.2)       & $c1$, $\neg c2$                                        \\ \hline
	    (2)       & $\neg c1$                                        \\ \hline
	\end{tabular}
\caption{Case splitting by equations for fkrm1 case of inv1}
\label{fig-cs-inv1iff}
\end{table}
The proof is semantically split into two subcases: (1)  \verb!c-fkrm1(s,d,e,r2) = true!,
and (2) \verb!c-fkrm1(s,d,e,r2)! \verb!= false!,
For the subcase (1), several additional equations with case splitting including auxiliary condition are used as assumptions to reduce each case.
% for the case fkrm1. 
% This case splitting cannot be handled by CiMPG. 
% Therefore, we modify the proof score for the subcase (1). 
The equations used for case splitting in Table \ref{fig-cs-inv1iff} are shown in Table.~\ref{fig-inv1iff}
\noindent
\begin{table}[]
	\begin{tabular}{l|l}
		\hline
		c1           &  r2 \verb!\in! ciphers(nw(s)) = true                                               \\ \hline
		c2         &   a = enemy                                                    \\ \hline
		c3         &    d = b                                                   \\ \hline
		c4 & e = c
		\\ \hline
		c5 & k(r2) = k
		\\ \hline
		c6   & r1(r2) = r1
		\\ \hline
		c7     & p(r2) = b
		\\ \hline
		c8       &   k = k(enemy)                                
		\\ \hline
		c9      & b = enemy
		
	\\ \hline
		
	    c10 &  enc(k,r1,enemy) \verb!\in! ciphers(nw(s)) = true
	    \\ \hline
	\end{tabular}
\caption{The equations used for case splitting in Table \ref{fig-cs-inv1iff}}
\label{fig-inv1iff}
\end{table}
% \begin{itemize}
% 	\item $c1 \triangleq$ \verb!r \in ur(p)!
% 	\item $c2 \triangleq$ \verb!i \in ui(p)!
% 	\item $c3 \triangleq$ \verb!m \in nw(p)!
% 	\item $c4 \triangleq$ \verb!ch?(m)!
% 	\item $c5 \triangleq$ \verb!dst(m) = b!
% 	\item $c6 \triangleq$ \verb!c \in list(m)!
% \end{itemize}


\subsection{Verifying IFF with CiMPA} \label{cimpa}
We present in this section the CafeInMaude Proof Assistant (CiMPA) and how to use it in IFF from the previous section. CiMPA is a tool that allows us to prove the properties in CafeOBJ specifications by using induction. The proof starts by introducing as the goal two equations that state that the invariants.
% \begin{small}
	\begin{verbatim}
		:goal{eq [iff1 :nonexec] : inv1(S:Sys,P:Prin,P1:Prin,
		P0:Prin,K:Key,R:Rand) = true .
			eq [iff :nonexec] : inv2(S:Sys,K:Key,R:Rand) = true . }
	\end{verbatim}
% \end{small}  
	\noindent
% where \verb!IFF! is the module in which the specification of IFF together two invariants. 
% Note that these equations are defined by using 
The attribute :nonexec indicates that the equations must not be used for reduction.
Then, we start proving the goals by applying simultaneous
induction on the variable \verb!S:Sys! by using: \verb!:ind on (S:Sys)!.
% :apply(si)!
% 	\begin{small}
% 		\begin{verbatim}
% 			:ind on (S:Sys) :apply(si)
% 		\end{verbatim}
% 	\end{small}
% where \verb!si! stands for simultaneous induction. 
The command \verb!:apply(si)! starts the proof by simultaneous induction on \verb!S!, generating six new goals for six constructors (\verb!fkcm1!, \verb!fkrm1!, \verb!fkrm2!, \verb!init!, \verb!sdcm! and \verb!sdrm!) in alphabetical order. Each subgoal consists of two equations to prove corresponding to inv1 and inv2. 

We will focus on the second goal for fkrm1, since it is the one that we worked with in the previous section. We start applying the theorem of constants by using the command: \verb!:apply(tc)!. The application of the theorem of constants splits the current goal into the following subgoals:
\begin{small}
	\begin{verbatim}
	2-1.> TC eq [iff1 :nonexec]: inv1(fkrm1(S#Sys,P#Prin,P0#Prin,
	C#Cipher),P@Prin, P1@Prin,P0@Prin,K@Key,R@Rand) = true .
	2-2. TC eq [iff :nonexec]: inv2(fkrm1(S#Sys,P#Prin,P0#Prin,
	C#Cipher),K@Key,R@Rand) = true .
	\end{verbatim}
\end{small}
where the > symbol indicates the current goal.
The command \verb!:apply(tc)! replaces CafeOBJ variables with fresh constants in goals. \verb!S#Sys!, \verb!P#Prin!, \verb!P0#Prin!, and \verb!C#Cipher! are fresh constants introduced by \verb!:apply(si)!, while \verb!P@Prin!, \verb!P1@Prin!, \verb!P0@Prin!, \verb!K@Key!, and \verb!R@Rand! are fresh constants introduced by \verb!:apply(tc)!.
In order to discharge goal 2-1, We need to distinguish cases as explained in the previous section; thus, we introduce the same
equations:
% 	\begin{small}
		\begin{verbatim}
			:def c1 = :ctf [C#Cipher \in ciphers(nw(S#Sys)) .]
			:def c2 = :ctf {eq P@Prin  = enemy .}
			:def c3 = :ctf {eq P#Prin  = P1@Prin .}
			:def c4 = :ctf {eq P0#Prin  = P0@Prin .}
			:def c5 = :ctf {eq k(C#Cipher) = K@Key .}
			:def c6 = :ctf {eq r(C#Cipher) = R@Rand .}
			:def c7 = :ctf {eq p(C#Cipher) = P1@Prin .}
			:def c8 = :ctf {eq K@Key  = k(enemy) .}
			:apply(c1 c2 c3 c4 c5 c6 c7 c8)
		\end{verbatim}
% 	\end{small}
	\noindent
Note that the order in the case splitting matters, since we will generate different sets of assumptions. Thus we apply them in order. Now we have nine new goals based on one Boolean term (c1) and seven equations (c2 to c8). As shown in Table \ref{fig-cs-inv1iff}, the first subgoal is 1.1.1.1.1.1.1.1 in which c1 is true and seven equations hold. To discharge this goal, we required use of an implication with the induction hypothesis. The induction hypothesis is instantiated by	replacing the variables with the fresh constants, and the instance is used as the premise of the implication. Thus, we indicate the substitution for the implication and apply a reduction as follows:
% \begin{small}
	\begin{verbatim}
		:imp [iff1] by {K:Key <- K@Key ; P0:Prin <- P0@Prin ;
		P1:Prin <- P1@Prin ; P:Prin <- P@Prin ; R:Rand <- R@Rand ;}
		:apply (rd)
		\end{verbatim}
% 	\end{small}
However, with the subgoal in which c1 is true, first six equations hold and the last equation does not hold, we need to conduct case splitting more as well as use inv2 as a lemma; this goal becomes 1.1.1.1.1.1.1.2.1.1 in Table \ref{fig-cs-inv1iff}:
	\begin{small}
		\begin{verbatim}
			:def c9 = :ctf {eq P1@Prin  = enemy .}
			:def c10 = :ctf [enc(K@Key,R@Rand,enemy) \in ciphers(nw(S#Sys)) .]
			:apply(c9 c10)
			:imp [iff] by {K:Key <- K@Key ; R:Rand <- R@Rand ;}
			:imp [iff1] by {K:Key <- K@Key ; P0:Prin <- P0@Prin ;
			P1:Prin <- P1@Prin ; P:Prin <- P@Prin ; R:Rand <- R@Rand ;}
			:apply (rd)
		\end{verbatim}
	\end{small}
	\noindent
The lemma inv2 is instantiated by replacing the variables
\verb!K:Key! and \verb!R:Rand! with the fresh constants \verb!K@Key! and \verb!R@Rand!, and the instance is used as the premise of the implication. Then, \verb!:apply(rd)! is used to discharge the current goal. The rest of the goals are discharged following the same ideas.
In comparison with proof scripts, proof scores are often easier to understand and more flexible than writing proof scripts. 
We will present in the following section a way to automatically generate the proof scripts from the proof scores.	

\subsection{Verifying IFF with CiMPG} \label{cimpg}
Although we are able to conduct the formal verification with
CiMPA, it would be preferable to automatically confirm the correctness of proof scores by CiMPG because CiMPA is easy to choose an erroneous order for the case distinctions, generating more goals than required and it is not a good idea to manually write the proof script when the size of the proof score is large. CiMPG generates proof scripts from proof scores, ensuring the correctness of the proof while allowing the user to freely use CafeOBJ syntax. We present in this section how to use CiMPG.
% and how CiMPG analyzes the proof scores to generate a proof script for CiMPA. 
% Note that the script generated is quite similar
% to that discussed in Section 3.3; thus, in some cases, we rely on the information presented in that
% section. 
First, we need to indicate that the proof scores refer to the same proof, which is done by using the :id() statement provided by the CiMPG. For instance, we use :id(iff) in all proof scores to state that they are related to the proof for goal iff. 
% Then, we ask the CiMPG to generate the proof score by using
% The following is the proof fragment for the case corresponding to goal 1.1.1.1.1.1.1.1 in the section \ref{fig-cs-inv1}:
% \begin{small}
% \begin{verbatim}
% open IFF .
% op a : -> Prin . op b : -> Prin . op c : -> Prin .
% op s : -> Sys .  op k : -> Key .  op r1 : -> Rand .
% op d : -> Prin . op e : -> Prin . op r2 : -> Cipher .
% eq r2 \in ciphers(nw(s)) = true .   eq a = enemy .
% eq d = b .  eq e = c .  eq k(r2) = k .  eq r1(r2) = r1 .    
% eq p(r2) = b .  eq k = k(enemy) .
% red implies inv1(s,a,b,c,k,r1) implies
% inv1(fkrm1(s,d,e,r2),a,b,c,k,r1) .
% close
% \end{verbatim}
% \end{small}
% \noindent
To use CiMPG, we need to add one more open-close fragment to the proof scores which consists of only one command \verb! :proof(iff)!; the proof fragment for fkrm1 for inv1 becomes as follows:
% \begin{small}
\begin{verbatim}
open IFF .
:proof(iff)
ops a b c d e : -> Prin . op s : -> Sys .  op k : -> Key .  
op r1 : -> Rand .   op r2 : -> Cipher .
eq r2 \in ciphers(nw(s)) = true .   eq a = enemy .
eq d = b .  eq e = c .  eq k(r2) = k .  eq r1(r2) = r1 .    
eq p(r2) = b .  eq k = k(enemy) .
red implies inv1(s,a,b,c,k,r1) implies
inv1(fkrm1(s,d,e,r2),a,b,c,k,r1) .
close
\end{verbatim}
% \end{small}
% \begin{small}
% 		\noindent
% 		\verb!open IFF .!\\
% 		\verb!  :proof(iff)!\\
% 		\verb!close!
% 		\smallskip
% \end{small}
% \noindent
where \verb!s! and \verb!k! correspond to \verb!S#Sys! and \verb!K@Key! in the last section.
\verb!a!, \verb!b!, \verb!c!, \verb!d!, and \verb!e! correspond to \verb!P@Prin!, \verb!P1@Prin!, \verb!P0@Prin!, \verb!P#Prin!, and \verb!P0#Prin!, respectively. \verb!r1! and \verb!r2! correspond to \verb!R@Rand! and \verb!R#Rand!.
Feeding the annotated proof scores into CiMPG, CiMPG generates the proof script for CiMPA. The proof script generated is quite similar to the one discussed in section \ref{cimpa}. Feeding the generated proof script into CiMPA, CiMPA discharges all goals, confirming that the proof scores are correct. The CiMPG continues in the same way proving the rest of the subgoals, finishing the proof.

% \section{TLS}\label{tls}
% TLS \cite{dierk} provides privacy and data integrity between client/server communications. The protocol consists of four sub-protocols. They are TLS handshake protocol, the change cipher spec protocol, the alert protocol and TLS record protocol. We focus on the TLS handshake protocol in this paper. When client and server want to establish a secure communication, TLS handshake protocol is used to negotiate a cipher suite and security parameters between client and server. 

% The change cipher spec protocol is used when each of two peers(client/server) want to notify the other that subsequent messages after handshake process will be protected under the newly negotiated cipher suite, and security parameters. If either of them notices something wrong, one lets the other know about it with the alert protocol. TLS record protocol provides private and reliable communications between the two peers using the negotiated cipher suite and security parameters.

% If a cipher suite used in the message is weaker than the available one to both peers or the security parameters shared by both peers are leaked by some reasons, then an adequate level of security cannot be obtained. Therefore, the security of TLS largely depends on a cipher suite and security parameters negotiated by client/ server in handshake process. Thus, it can be said that among four sub-protocols, TLS handshake protocol takes part in the most important role and the security of TLS relies on TLS handshake protocol. 

\begin{table}[]
\centering
    \begin{tabular}{ c c c }
    Client &  & Server \\ 
    \hline
    & $\leftarrow$ & HelloRequest$^*$ \\  
    ClientHello & $\rightarrow$ & \\ 
    & $\leftarrow$ & ServerHello \\  
    & $\leftarrow$ & Certificate$^*$ \\  
    & $\leftarrow$ & ServerKeyExchange$^*$ \\  
    & $\leftarrow$ & CertificateRequest$^*$ \\  
    & $\leftarrow$ & ServerHelloDone$^*$ \\  
    Certificate$^*$ & $\rightarrow$ & \\ 
    ClientKeyExchange & $\rightarrow$ & \\ 
    CertificateVerify$^*$ & $\rightarrow$ & \\ 
    \verb![ChangeCipherSpec]! & $\rightarrow$ & \\ 
    Finished & $\rightarrow$ & \\ 
    & $\leftarrow$ & \verb![ChangeCipherSpec]! \\  
    & $\leftarrow$ & Finished \\ 
    Application Data & $\leftrightarrow$ & Application Data \\ 
    \end{tabular}
    \caption{TLS handshake protocol}
    \label{tab:tb1}
\end{table}

\section{TLS handshake protocol}\label{tls}
Table \ref{tab:tb1} shows the message exchanges between client and server in TLS handshake protocol, which is formally verified in the present paper. To initiate a new run of the protocol, a server sends a HelloRequest message to a client or a client sends a ClientHello message to the server. On receipt of the HelloRequest message from server, the client replies to server with a ClientHello message. A ClientHello message contains the basic information, such as a version number of TLS, a list of cipher suites that are available to the client, a random number generated by client.

On the receipt of the ClientHello message, the server replies to the client with a ServerHello message, which consists of a version number of TLS that is lower than or equal to the one suggested by the client and the highest supported by the server, a session ID, a cipher suite chosen from the list suggested by the client in the ClientHello message, a random number generated by server, etc. 

If the server should be authenticated, the server sends  his/her certificate to the client. If the server Certificate message does not contain enough data to allow the client to exchange a pre-master secret, the server sends a ServerKeyExchange message to the client. The server can optionally request a certificate from the client by sending a CertificateRequest message. The server sends a ServerHelloDone message to the client to indicate the end of the ServerHello.

When the client receives ServerHelloDone message, the client checks the messages received. When it is necessary, the client sends his/her certificate to the server. The ClientKeyExchange message is sent by the client after he/she receives a ServerHelloDone message. The ClientKeyExchange message contains a pre-master secret which is a random number generated by the client. Two key exchange methods (RSA and Diffie-Hellman) are specified to exchange a pre-master secret. 

The client can optionally send a CertificateVerify message to provide a verification of the client certificate.
The client notifies the server with the change cipher spec protocol that subsequent messages will be protected under the newly negotiated cipher suite and security parameters and sends a Finished message to the server. The Finished message is protected under the just negotiated cipher suite and security parameters.

On receipt of the client Finished message from the client, the server
checks the message. If the message is correct, the server notifies the client with the change cipher spec protocol that subsequent messages will be protected under the newly negotiated cipher suite and security parameters. The server then sends a server Finished message to the client to verify that the handshake process is successful.

The client checks the message when the server Finished message is received. If the message is correct, the handshake process is done successfully between client and server and the client can exchange application data securely with server in the current session.

A previously established session and a current session
can be resumed and/or duplicated without exchanging all handshake messages. If a client wants to resume or duplicate a session, he/she sets a session ID in a new ClientHello message and sends it to a server. When the ClientHello message is received, if the server wants to resume or duplicate the session, he/she replies to the client with a new ServerHello message. The ClientHello and ServerHello messages are protected under the current cipher suite and security parameters. 

The server then notifies the client to use the newly negotiated security parameters for the session with the same cipher suite. A server Finished message is then sent to the client. On receipt of the server Finished message, the client checks the message received. If the message is correct, the client notifies the server to use the newly negotiated security parameters for the session and a client Finished message is then sent to the server. The server checks the message on the receipt of the client Finished message. If the message is correct, the session is then resumed and/or duplicated. The client can exchange application data securely with server in that session.
\noindent
\begin{table}[]
\centering
%  \caption{An abstract handshake protocol}
    \begin{tabular}{ c c c }
    ClientHello & $A \rightarrow B$  & Rand$_A$, ListOfChoices \\ 
    ServerHello & $B \rightarrow A$ & Rand$_B$, SID, Choice \\  
    Certificate & $B \rightarrow A$ & Cert$_B$ \\ 
    KeyExchange & $A \rightarrow B$ & $\varepsilon_{K_B}$(PMS) \\ 
    ClientFinished & $A \rightarrow B$ & $\varepsilon_{ClientKey}$(ClientFinish) \\
   ServerFinished & $B \rightarrow A$ & $\varepsilon_{ServerKey}$(ServerFinish) \\
   \\
   ClientHello2 & $A \rightarrow B$  & Rand$_A$, SID \\
   ServerHello2 & $B \rightarrow A$ & Rand$_B$, SID, Choice \\
   ServerFinished2 & $B \rightarrow A$ & $\varepsilon_{ServerKey}$(ServerFinish2) \\
   ClientFinished2 & $A \rightarrow B$ & $\varepsilon_{ClientKey}$(ClientFinish2) \\
    \end{tabular}
     \caption{An abstract handshake protocol}
    % \setlength{\parindent}{4em}
   
    \label{tab:tb2}
\end{table}
\noindent
% \subsection{The Abstract Handshake Protocol}\label{abstracthandshake}
Table \ref{tab:tb2} shows the abstract version of TLS handshake protocol. In the protocol, \verb!A! denotes a client and \verb!B! a server respectively. In the table, the first six exchanged messages are the full handshake process between the client and the server. The remaining ones are for the resumption of a previously established session or the duplication of a current session.

% Cryptographic functions used in the protocol are H(.)
% (a one-way hash function), $\varepsilon_K(.)$ (an encryption function with symmetric or asymmetric key K) and S$_X(.)$ (a digital signature function with principal X’s private key). The other primitives used in the protocol are Rand$_X$ (a random number generated by principal X), ListOfChoices (a list of cipher suites), Choice (a cipher suite), SID (a session ID), PMS (a pre-master secret), CA (certificate authority) and K$_X$ (principal X's public key).

% Composite data occurring in the protocol are as follows:
% Cert$_X$ : X, K$_X$, S$_{CA}$(X, K$_X$) \newline
% ClientKey : H(A, PMS, Rand$_A$, Rand$_B$) \newline
% ClientKey : H(B, PMS, Rand$_A$, Rand$_B$) \newline
% ClientFinish : H("client", A, B, SID, ListOfChoices, Choice, Rand$_A$, Rand$_B$, PMS)\newline
% ServerFinish : H("server", A, B, SID, ListOfChoices, Choice, Rand$_A$, Rand$_B$, PMS)\newline
% ClientFinish2 : H("client", A, B, SID, Choice, Rand$_A$, Rand$_B$, PMS)\newline
% ServerFinish2 : H("server", A, B, SID, Choice, Rand$_A$, Rand$_B$, PMS)\newline

% There are some assumptions in the abstract handshake protocol as follows:
% \begin{itemize}
% \item A server always sends his/her certificate to a client in handshake process; 
% \item A server sends neither SeverKeyExchange nor CertificateRequest messages; 
% \item A client sends neither Certificate nor CertificateVerify messages; \item The ChangeCipherSpec messages are implicit and not considered in the abstract handshake protocol; 
% \item There exists only one trusted certificate authority denoted by CA; 
% \item Only RSA method is used for exchanging pre-master secrets; 
% \item The content of Finished messages is not the hash of the security parameters and handshake messages exchanged, but that of two random numbers, a pre-master secret, etc.
% \end{itemize}

\section{Formal Specification of TLS handshake protocol} \label{fstls}
% \textbf{TO REVISE THIS PART}
The formal specification of the protocol written in CafeOBJ is available and the modeling of the system has already been described in \cite{1437139}. We slightly revise the existing specification and the description of the formal specification of the protocol is given in this section. 
% There are two special principals, certificate 
% two kinds of principals such as trustable and untrustable ones. --here
% Trustable principals exactly follow the protocol, while untrustable ones do something against the protocol. 
% Suppose that there exists not only multiple trustable
% principals but also multiple malicious (untrustable) principals, and the cryptosystem used is perfect. Trustable
% principals exactly follow the protocol, while malicious ones may do something against the protocol as well. The combination and cooperation of malicious principals is modeled as the most general intruder Dolev-Yao \cite{dolev}. 
% An intruder can glean as much information as possible from messages flowing in the network and create fake messages based on the gleaned information, provided that the intruder cannot break the perfect cryptosystem.
% We specify 10 operators (data construtors) to define 10 kinds of messages. The data constructors used in TLS are declared as follows:
The 10 kinds of messages are defined with operators as data constructors for which sort Msg is declared. The messages are ch, sh, ct, kx, cf, sf, ch2, sh2, cf2 and sf2 respectively.
% declared as follows.
% \begin{small}
% 		\begin{verbatim}
% op ch  : Prin    Prin   Prin  Rand ListOfChoices -> Msg
% op sh  : Prin    Prin   Prin  Rand Sid Choice    -> Msg
% op ct  : Prin    Prin   Prin  Cert               -> Msg
% op kx  : Prin    Prin   Prin  EncPms             -> Msg
% op cf  : Prin    Prin   Prin  EncCFin            -> Msg
% op sf  : Prin    Prin   Prin  EncSFin            -> Msg
% op ch2 : Prin    Prin   Prin  Rand Sid           -> Msg
% op sh2 : Prin    Prin   Prin  Rand Sid Choice    -> Msg
% op cf2 : Prin    Prin   Prin  EncCFin2           -> Msg
% op sf2 : Prin    Prin   Prin  EncSFin2           -> Msg
% 		\end{verbatim}
% 	\end{small}
% where \verb!Msg! is the sort denoting messages. 
For each data constructor \verb!x!, the predicate \verb!x!? is defined to check if a given message is \verb!x! message (where \verb!x = ch!, \verb!sh!, \verb!ct!, \verb!kx!, \verb!cf!, \verb!sf!, \verb!ch2,! \verb!sh2!, \verb!sf2!, \verb!cf2!).
The other sorts and the corresponding data
constructors that constitute the messages are declared as follows:
\begin{itemize}
  \item There are an arbitrary number of principles including two special principals; one is the \verb!intruder! and the other the certificate authority denoted by \verb!ca! for which sort Prin is declared. We suppose that \verb!intruder! does not equal \verb!ca!. 
  \item \verb!Rand! denotes random numbers generated by principals and
\verb!ListOfChoices! denotes lists of cipher suites. Operator \verb|_\in_| is the membership predicate of lists.
  \item \verb!Choice! denotes cipher suites, \verb!Sid! denotes session IDs and \verb!PubKey! denotes public keys. The principal $a$’s public key is denoted by \verb!k!($a$).
\item \verb!Sig! denotes digital signatures of pairs of a principal and a public key. The digital signature of the pair of principal $b$ and public key $k$ signed by $ca$ is denoted by \verb!sig!($ca$, $b$, $k$).
\item \verb!Cert! denotes certificates of public keys. Given principal $a$, public key $k$ and signature $g$, the certificate that $k$ is $a$’s, which is certified by $g$, is denoted by \verb!cert!($a$, $k$, $g$).
\item \verb!Secret! denotes secret values that make pre-master secret globally unique and unguessable and \verb!Pms! denotes premaster secrets. Given two principals $a,b$ and a secret value $s$, a pre-master secret generated by client $a$ for server $b$ is denoted by \verb!pms!($a$, $b$, $s$).
\item \verb!Key! denotes hashes used as symmetric keys to encrypt Finished messages. Given principal $a$, pre-master secret $pms$ and two random numbers $r1,r2$, the hash of those quantities is denoted by \verb!k!($a$, $pms$, $r1, r2$).
\item \verb!CFinish! denotes ClientFinish’s. Given two principals $a, b$, session ID $i$, list $l$ of cipher suites, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ClientFinish is denoted by \verb!cfin!($a, b$, $i$, $l$, $c$, $r1, r2$, $s$).
\item \verb!SFinish! denotes ServerFinish’s. Given two principals $a, b$, session ID $i$, list $l$ of cipher suites, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ServerFinish is denoted by \verb!sfin!($a, b$, $i$, $l$, $c$, $r1, r2$, $s$).
\item \verb!CFinish2! denotes ClientFinish2’s. Given two principals $a, b$, session ID $i$, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ClientFinish is denoted by \verb!cfin2!($a, b$, $i$, $c$, $r1, r2$, $s$).
\item \verb!SFinish2! denotes ServerFinish2’s. Given two principals $a, b$, session ID $i$, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ServerFinish is denoted by \verb!sfin2!($a, b$, $i$, $c$, $r1, r2$, $s$).
\item \verb!EncPms! denotes pre-master secrets encrypted by public keys. Pre-master secret $pms$ encrypted by public key $k$ is denoted by \verb!epms!($k$, $pms$).
\item \verb!EncCFin! denotes ClientFinish’s encrypted by symmetric keys. ClientFinish $f$ encrypted by symmetric key $k$ denoted by \verb!ecfin!($k$, $f$).
\item \verb!EncSFin! denotes ServerFinish’s encrypted by symmetric keys. ServerFinish $f$ encrypted by symmetric key $k$ denoted by \verb!esfin!($k$, $f$).
\item \verb!EncCFin2! denotes ClientFinish2’s encrypted by symmetric keys. ClientFinish2 $f$ encrypted by symmetric key $k$ denoted by \verb!ecfin2!($k$, $f$).
\item \verb!EncSFin2! denotes ServerFinish2’s encrypted by symmetric keys. ServerFinish2 $f$ encrypted by symmetric key $k$ denoted by \verb!esfin2!($k$, $f$).
\item \verb!Session! denotes a quadruple of a cipher suite, two random numbers and a pre-master secret. A quadruple of cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $pms$ is denoted by \verb!st!($c$, $r1, r2$, $pms$).
\end{itemize}

The projection operators are defined to return the arguments of the data constructors. The projection operators for a message such as \verb!crt!, \verb!src! and \verb!dst! return the first, second and third arguments of the message, respectively. 
% The first, second and  third  arguments  of  each  message are  the  actual creator,  the  seeming  sender  and  the  receiver  of the  corresponding message. 
The other projection operators 
% such as \verb!client(pms!($a$, $b$, $s$)) = $a$, \verb!server(pms!($a$, $b$, $s$)) = $b$ and \verb!secret(pms!($a$, $b$, $s$)) = $s$ 
are also defined likewise.
% For each data constructor such as \verb!pms!, \verb!sig!, etc., projection operators such as \verb!client!, \verb!server! and \verb!secret! that return arguments of the data constructor are also defined. For example, \verb!client(pms!($a$, $b$, $s$)) = $a$, \verb!server(pms!($a$, $b$, $s$)) = $b$ and \verb!secret(pms!($a$, $b$, $s$)) = $s$. Other projection operators for other data constructor are also defined likewise.
%  Given a term denoting a message,  The first, second and  third  arguments  of  each  message are  the  actual creator,  the  seeming  sender  and  the  receiver  of the  corresponding message. The first argument is meta-information that is only available to the outside observer and that cannot be forged by the intruder; while the remaining arguments may be forged by the intruder. 
% Suppose that there exists a message in the network. It is true that the principal denoted by the first
% argument has sent the message. If the first argument is the
% intruder and the second one is not, then the message has been
% faked by the intruder. For example, a principal $a$ receives a message denoted by \verb!ct!($b$', $b$, $a$, $cert$). 
% Since messages are supposed to be never deleted from the network, if there exists a message denoted by
% \verb!ct!($b$, $b$, $a$, $cert$) the network, we can conclude that the message received by $a$ really originates from $b$.
% Therefore, this formalization of messages makes it possible to describe a property such as one that a message received by a principal really originates from the seeming sender (second argument) of the message. 
% The  network  is  modeled  as  a  multiset  of  messages,  in which the intruder can use as his/her storage. Any message that has been sent or put once into the network is supposed to be never deleted from the network because the intruder can replay the message repeatedly, although the intruder cannot forge the first argument. Consequently, the empty network (i.e., the empty multiset) means that no messages have been sent.
% The  network  is  modeled  as  a  bag (multiset)  of  messages,  in which each principal’s storage. Any message that has been sent into the network is supposed to be never deleted from the network because the intruder can replay the message repeatedly, although the intruder cannot forge the first argument. The empty network means that no messages have been sent.
% The intruder tries to glean seven kinds of quantities from
% the network as much as possible. The seven kinds of quantities are pre-master secrets, digital signatures and five kinds of ciphertexts.
% \noindent
The collections of the seven quantities gleaned by the intruder from the network are denoted by the following operators, respectively:
\begin{small}
\begin{verbatim}
op cpms : Network -> ColPms op cesfin : Network -> ColEncSFin
op cepms : Network -> ColEncPms op cecfin : Network -> ColEncCFin
op cecfin2 : Network -> ColEncCFin2 op csig : Network -> ColSig
op cesfin2 : Network -> ColEncSFin2 
\end{verbatim}
\end{small}	
where Network is the sort denoting networks. Col$X$ is
the sort denoting collections of quantities denoted
by sort $X$. Each operator is defined with equations.
% The operators are defined with equations. For example, the operator \verb!cpms! is defined with equations as follows:
% \begin{small}
% \begin{verbatim}
% eq PMS \in cpms(void) = (client(PMS) = intruder) .
% ceq PMS \in cpms(M,NW) = true if (kx?(M) and
% owner(k(epms(M))) = intruder and PMS = pms(epms(M))) .
% ceq PMS \in cpms(M,NW) = PMS \in cpms(NW) if not(kx?(M) and
% owner(k(epms(M))) = intruder and PMS = pms(epms(M))) .
% \end{verbatim}
% \end{small}	
% where constant \verb!void! denotes the empty bag. Operator    \verb|_,_| of \verb!M,NW! is the data constructor of bags. The first equation says that any pre-master secret generated by the intruder is always available to the intruder and no other pre-master secrets are at any initial state. Messages from which pre-master secrets can be gleaned are Certificate messages only. The second equation says that if there exits a Certificate message in the network and the ciphertext in the message is encrypted with the intruder’s public key, then the pre-master secret in the message can be available to the intruder. The third one says that no pre-master secrets cannot be gleaned from any non-Certificate messages and any Certificate messages whose ciphertexts are not encrypted with the intruder’s public key. The remaining operators are also defined likewise.
% \noindent 
% The operator \verb!cepms! is defined with equations as follows:
% \begin{small}
% \begin{verbatim}
% eq EPMS \in cepms(void) = false .
% ceq EPMS \in cepms(M,NW) = true if (kx?(M) and 
% not(owner(k(epms(M))) = intruder) and EPMS = epms(M)) .
% ceq EPMS \in cepms(M,NW) = EPMS \in cepms(NW) if not(kx?(M) and
% not(owner(k(epms(M))) = intruder) and EPMS = epms(M)) .
% \end{verbatim}
% \end{small}	
% where constant \verb!void! denotes the empty bag. Operator    \verb|_,_| of \verb!M,NW! is the data constructor of bags. Messages from which encrypted pre-master secrets can be gleaned are KeyExchange messages only. The equations say that if there exits a KeyExchange message in the network and the pre-master secret in the message is not
% encrypted with the intruder’s public key, then the intruder can glean the encrypted pre-master secret in the message.
% The second equation says that if there exits a KeyExchange message in the network and the pre-master secret in the message is not encrypted with the intruder’s public key, then the encrypted pre-master secret in the message can be available to the intruder. The third one says that no encrypted pre-master secrets cannot be gleaned from any non-KeyExchange messages and any KeyExchange messages whose pre-master secrets are encrypted with the intruder’s public key. 
% The remaining operators are also defined likewise.
There are five observational functions such as \verb!nw, ur, us, ui! and \verb!ss! for which sort
% have been declared as follows:
% \begin{small}
% \begin{verbatim}
% op nw : Protocol -> Network   op ur : Protocol -> URand
% op ss : Protocol Prin Prin Sid -> Session
% op ui : Protocol -> USid     op us : Protocol -> USecret
% \end{verbatim}
% % \end{small}	
% where 
\verb!Protocol! denoting  the  state  space, sorts \verb!URand!, \verb!USid! and \verb!USecret! denoting sets of random numbers, ones of session IDs and ones of secrets are declared.
Let $p$ denotes a state of the protocol. \verb!nw!($p$) denotes the network, \verb!ur!($p$) the set of used random numbers, \verb!ui!($p$) that of used session IDs and \verb!us!($p$) that of used secrets in the state. 
\verb!ss!($p$, $a$, $b$, $i$) denotes the principal $a$’s session state identified by session ID $i$ with principal $b$ in the state where $a, b$ denotes principals and $i$ a session ID.

% The behaviors of the principals are modeled by transitions. 
The transitions are defined by operators in CafeOBJ. The behavior of trustable principals is defined by 12 kinds of transitions corresponding to sending ten kinds of messages and receiving two Finished messages; chello, shello, cert,
kexch, cfin, sfin, compl, chello2,shello2, cfin2, sfin2 and compl2 respectively. The behavior of the intruder is modeled by 15 kinds of transitions; fakeChello, fakeShello, fakeCert,
fakeKexch1, fakeKexch2,
fakeCfin1, fakeCfin2, fakeSfin1,
fakeSfin2, fakeChello2,
fakeShello2, fakeCfin21, fakeCfin22, fakeSfin21 and
fakeSfin22 respectively.
% We define 27 transitions together with one constant of \verb!Protocol! to represent an arbitrary initial state.
% The behavior of trustable principals is modeled by 12
% kinds of transitions. 10 of them correspond to sending
% the 10 kinds of messages. The remaining two correspond
% to clients’ receiving ServerFinished messages and
% servers’ receiving ClientFinished2 messages, respectively.
% The 12 kinds of transitions are 
% denoted by the following operators:
% \begin{small}
% \begin{verbatim}
% op chello : Protocol Prin Prin Rand ListOfChoices ->
% Protocol {constr}
% op shello : Protocol Prin Rand Sid Choice Msg -> Protocol {constr}
% op cert : Protocol Prin Msg Msg -> Protocol {constr}
% op kexch : Protocol Prin Secret Msg Msg Msg -> Protocol {constr}
% op cfin : Protocol Prin Secret Msg Msg Msg Msg -> Protocol {constr}
% op sfin : Protocol Prin Msg Msg Msg Msg Msg -> Protocol {constr}
% op compl : Protocol Prin Secret Msg Msg Msg Msg Msg Msg ->
% Protocol {constr}
% op chello2 : Protocol Prin Prin Secret Rand Sid -> 
% Protocol {constr}
% op shello2 : Protocol Prin Rand Msg -> Protocol {constr}
% op cfin2 : Protocol Prin Secret Msg Msg -> Protocol {constr}
% op sfin2 : Protocol Prin Msg Msg Msg -> Protocol {constr}
% op compl2 : Protocol Prin Secret Msg Msg Msg Msg -> 
% Protocol {constr} 
% \end{verbatim}
% \end{small}	
% Each transition is defined with equations.
% The 12 action operators are defined with equations. 
In this paper, we show the equations for \verb!shello!, which are declared as follows:
\begin{small}
\begin{verbatim}
op c-shello : Protocol Prin Rand Sid Choice Msg -> Bool
eq c-shello(P,B,R,I,C,M) = (not(R \in ur(P)) and not(I \in ui(P)) 
and M \in nw(P) and ch?(M) and dst(M) = B and C \in list(M)) .
ceq nw(shello(P,B,R,I,C,M)) = sh(B,B,src(M),R,I,C) , nw(P) 
if c-shello(P,B,R,I,C,M) .
eq  ss(shello(P,B,R,I,C,M),A2,B2,I2) = ss(P,A2,B2,I2) .
ceq ur(shello(P,B,R,I,C,M)) = R ur(P) if c-shello(P,B,R,I,C,M) .
ceq ui(shello(P,B,R,I,C,M)) = I ui(P) if c-shello(P,B,R,I,C,M) .
eq  us(shello(P,B,R,I,C,M)) = us(P) .
ceq shello(P,B,R,I,C,M)     = P if not c-shello(P,B,R,I,C,M) .
\end{verbatim}
\end{small}	
where A, A2, B and B2 are CafeOBJ variables of the sort Prin, I2 and I are CafeOBJ variables of the sort Sid and P, R, C and M are CafeOBJ variables of the sorts Protocol, Rand, Choice and Msg respectively.
The  equations  say  that  if c-shello(P,B,R,I,C,M) is  true
(i.e., random number R has not been used, section ID I has not been set and a ClientHello message is in the network), then the ServerHello message sh(B,B,src(M),R,I,C) is put into the network nw(P), R is put into ur(P) and I is put into ui(P); if c-shello(P,B,R,I,C,M) is  false,  nothing  changes.  The remaining transitions can be defined likewise.
% The intruder fakes messages based on the gleaned information. 
% The effective condition to the action operators is that the necessary information is available to the intruder. 
% The 15 kinds of transitions are 
% defined by the following operators:
% \begin{small}
% \begin{verbatim}
% op fakeChello : Protocol Prin Prin Rand ListOfChoices ->
% Protocol {constr}
% op fakeShello : Protocol Prin Prin Rand Sid Choice ->
% Protocol {constr}
% op fakeCert : Protocol Prin Prin PubKey Sig -> Protocol {constr}
% op fakeKexch1 : Protocol Prin Prin EncPms -> Protocol {constr}
% op fakeKexch2 : Protocol Prin Prin PubKey Pms -> Protocol {constr}
% op fakeCfin1 : Protocol Prin Prin EncCFin -> Protocol {constr}
% op fakeCfin2 : Protocol Prin Prin Sid ListOfChoices Choice Rand 
% Rand Pms -> Protocol {constr}
% op fakeSfin1 : Protocol Prin Prin EncSFin -> Protocol {constr}
% op fakeSfin2 : Protocol Prin Prin Sid ListOfChoices Choice Rand 
% Rand Pms -> Protocol {constr}
% op fakeChello2 : Protocol Prin Prin Rand Sid -> Protocol {constr}
% op fakeShello2 : Protocol Prin Prin Rand Sid Choice ->
% Protocol {constr}
% op fakeCfin21  : Protocol Prin Prin EncCFin2 -> Protocol {constr}
% op fakeCfin22  : Protocol Prin Prin Sid Choice Rand Rand Pms -> 
% Protocol {constr}
% op fakeSfin21  : Protocol Prin Prin EncSFin2 -> Protocol {constr}
% op fakeSfin22  : Protocol Prin Prin Sid Choice Rand Rand Pms -> 
% Protocol {constr} 
% \end{verbatim}
% \end{small}	
% Each operator is defined with equations. 
In the existing specification of the protocol, the state space is denoted by hidden sort. The transition and observation operators with respect to hidden sorts are declared by starting with \verb !bop!. We slightly revise the original specification of the state space denoting visible sort and the transition and observation operators are declared with respect to visible sorts by starting with \verb !op! since behavioral specifications are not supported in CafeInMaude.

\subsection{Five properties of TLS protocol}
The five properties of the protocol are formalized as CafeOBJ terms in \cite{1437139}. They are (1) the secrecy property of pre-master secrets, (2) the correspondence (or authentication) one from a client point of view, (3) the correspondence one from a server point of view, (4) the correspondence one for resumed sessions from a client point of view, and (5) the correspondence one for resumed sessions from a server point of view. 13 lemmas are used by Ogata and Futatsugi to formally verify these five properties. 
% Moreover, we found one missing lemma and it is required to use in the formal verification of the protocol with CiMPG. 
% In this paper, the word property is used interchangeably with invariant. 
Let us refer to the properties and lemmas as inv\textbf{$x$} where x = 1 to 18 where inv1, inv3, inv5, inv17 and inv18 represent the five properties of the protocol. The first property is formalized as follows: 
% \begin{small}
\begin{verbatim}
eq inv1(P,PMS) = (PMS \in cpms(nw(P)) implies 
(client(PMS) = intruder or server(PMS) = intruder)) .
\end{verbatim}
% \end{small}
where P and PMS are CafeOBJ variables of the sort Prin and Pms. The equation says that if a pre-master secret is available to the intruder as a server, the pre-master secret has been generated by the intruder or a client has generated it for a session with the intruder. This means that pre-master secrets cannot be leaked and the intruder cannot obtain any pre-master secrets for sessions in which the intruder is not involved. .

The second property is specified as follows:
% \begin{small}
\begin{verbatim}
eq inv3(P,A,B,B1,R1,R2,L,C,I,S) = (not(A = intruder) and 
sf(B1,B,A,esfin(k(B,pms(A,B,S),R1,R2),sfin(A,B,I,L,C,R1,
R2,pms(A,B,S)))) \in nw(P) implies
sf(B,B,A,esfin(k(B,pms(A,B,S),R1,R2),sfin(A,B,I,L,C,
R2,pms(A,B,S)))) \in nw(P)) .
\end{verbatim}
% \end{small}
where A, B and B1 are CafeOBJ variables of Prin, R1 and R2 are CafeOBJ variables of Rand, and L, C, I and S are CafeOBJ variables of the sorts ListOfChoices, Choice, Sid and Secret respectively . The property says that whenever the trustable client receives a ServerFinished message which is seemingly sent by a server, then the message really originates from the server. 
% hat means that
% whenever the client A received a ServerFinished message
% seemingly from the server B, the server that A is communi-
% cating with is really B even though there are malicious prin-
% cipals (e.g., B1). 
% The second property guarantees that when a client has negotiated a cipher suite and security parameters with the corresponding server by a full handshake process, the server has really agreed on them.

The third property is formally specified as follows:
% \begin{small}
\begin{verbatim}
eq inv5(P,A,B,B1,R1,R2,C,I,S) = (not(A = intruder) and
sf2(B1,B,A,esfin2(k(B,pms(A,B,S),R1,R2),sfin2(A,B,I,C,R1,
R2,pms(A,B,S)))) \in nw(P) implies
sf2(B,B,A,esfin2(k(B,pms(A,B,S),R1,R2),sfin2(A,B,I,C,R1,
R2,pms(A,B,S)))) \in nw(P)) .
\end{verbatim}
% \end{small}
The property says that whenever the trustable client receives a ServerFinished2 message that is seemingly sent by a server, then the message really originates from the server.  

The fourth property is formalized as follows:
\begin{small}
\begin{verbatim}
eq inv17(P,A,B,B1,B2,B3,R1,R2,L,C,I,S,K) = (not(A = intruder) and
sh(B1,B,A,R2,I,C) \in nw(P) and ct(B2,B,A,cert(B,K,sig(ca,B,K)))
\in nw(P) and sf(B3,B,A,esfin(k(B,pms(A,B,S),R1,R2),
sfin(A,B,I,L,C,R1,R2,pms(A,B,S)))) \in nw(P) implies
sh(B,B,A,R2,I,C) \in nw(P) and ct(B,B,A,cert(B,K,sig(ca,B,K))) 
\in nw(P)) .
\end{verbatim}
\end{small}
This property means that if a trustable client receives a ServerHello message, a Certificate message and a ServerFinished message that are seemingly sent by a server, then the ServerHello and Certificate messages really originate from the server.

The fifth property is specified as follows:
% \begin{small}
\begin{verbatim}
eq inv18(P,A,B,B1,B2,R1,R2,C,I,S) = (not(A = intruder) and 
sh2(B1,B,A,R2,I,C) \in nw(P) and sf2(B2,B,A,esfin2(k(B,
pms(A,B,S),R1,R2),sfin2(A,B,I,C,R1,R2,pms(A,B,S)))) \in 
nw(P) implies sh2(B,B,A,R2,I,C) \in nw(P)) .
\end{verbatim}
% \end{small}
The property says that if a trustable client receives a ServerHello2 message and
a ServerFinished2 message that is seemingly sent by a server, then the ServerHello2
message really originate2 from the server.

% Authentication property is that after a successful
% run of the protocol by principals p1 and p2,
% (1) the principal whom p1 is communicating with is p2,
% and
% (2) the principal whom p2 is communicating with is p1. 

\section{Revising the existing proof scores and one Missing lemma}
\label{revision}
We describe in this section some examples on how to revise the existing proof scores so that CiMPG can handle them. The five invariants such as inv12, inv13, inv16, inv17 and inv18 have been proved by case analysis with other invariants, and the remaining ones by (simultaneous) structural induction on reachable states in \cite{1437139}. CiMPG cannot deal with the proofs by case analysis. Thus, it is necessary to prove the five invariants by structural induction. We have written proof scores for those five ones by using structural induction.
% while referring to some tips on writing proof scores \cite{Ogata2006}. 
In the existing proof scores of the protocol, semantic-based case splittings are used several times. 
However, this case splitting cannot be handled by CiMPG. Thus, we need to revise the proof scores to get rid of any case splitting based on semantics. 
For example, the induction case \verb!shello! of inv1 consists of the following two open-close fragments:
% \begin{small}
\begin{verbatim}
open ISTEP .
	ops p p' : -> Protocol .  op pms : -> Pms .  op b : -> Prin .
	op c : -> Choice .        op r : -> Rand .   op i : -> Sid . 
	op nw10 : -> Network .    op m : -> Msg .           
	eq r \in ur(p) = false .  eq i \in ui(p) = false .
	eq nw(p) = m , nw10 .     eq ch?(m) = true . eq dst(m) = b .
	eq c \in list(m) = true . 
	eq p' = shello(p,b,r,i,c,m) .
	red istep1(pms) .
	close
	open ISTEP .
	ops p p' : -> Protocol .  op pms : -> Pms .  op b : -> Prin .
	op c : -> Choice .        op r : -> Rand .   op i : -> Sid . 
	op nw10 : -> Network .    op m : -> Msg .           
	eq c-shello(p,b,r,i,c,m) = false . 
	eq p' = shello(p,b,r,i,c,m) .
	red istep1(pms) .
	close
\end{verbatim}
% \end{small}
\noindent
where \verb!istep1(pms)! is \verb!inv1(p,pms) implies inv1(p',pms)!.
The proof is semantically split into two subcases: (1)  \verb!c-shello(p,!\\\verb!b,r,i,c,m) = true!, which corresponds to the first open-close fragment above; 
and (2) \verb!c-shello(p,b,r,i,c,m)! \verb!= false!,
which corresponds to the second open-close fragment above. 
For the subcase (1), based on the definition of \verb!c-shello!,  \verb!c-shello(p,b,r,i,c,m) = true! is rewritten into the first five equations in the first open-close fragment. 
This case splitting is semantically correct, but unfortunately, cannot be handled by CiMPG. 
Therefore, we need to modify the proof score. 
The revised proof score consists of seven subcases as shown in Table.~\ref{fig-cs-inv1}, where $c1$, $c2$, $c3$, $c4$, $c5$, and $c6$ are
 \verb!r \in ur(p)!,
 \verb!i \in ui(p)!,
 \verb!m \in nw(p)!,
 \verb!ch?(m)!,
 \verb!dst(m) = b!, and
 \verb!c \in list(m)!, respectively. 
%\begin{itemize}
%	\item $c1 \triangleq$ \verb!r \in ur(p)!
%	\item $c2 \triangleq$ \verb!i \in ui(p)!
%	\item $c3 \triangleq$ \verb!m \in nw(p)!
%	\item $c4 \triangleq$ \verb!ch?(m)!
%	\item $c5 \triangleq$ \verb!dst(m) = b!
%	\item $c6 \triangleq$ \verb!c \in list(m)!
%\end{itemize}
\noindent
\begin{table}[]
	\begin{tabular}{l|l}
		\hline
		(1)           & $c1$                                                                     \\ \hline
		(2.1)         & $\neg c1$, $c2$                                                       \\ \hline
		(2.2.1.1.1.1) & $\neg c1$, $\neg c2$, $c3$, $c4$, $c5$, $c6$  \\ \hline
		(2.2.1.1.1.2) & $\neg c1$, $\neg c2$, $c3$, $c4$, $c5$, $\neg c6$ \\ \hline
		(2.2.1.1.2)   & $\neg c1$, $\neg c2$, $c3$, $c4$, $\neg c5$              \\ \hline
		(2.2.1.2)     & $\neg c1$, $\neg c2$, $c3$, $\neg c4$                           \\ \hline
		(2.2.2)       & $\neg c1$, $\neg c2$, $\neg c3$                                        \\ \hline
	\end{tabular}
\caption{Case splitting for the induction case shello of inv1}
\label{fig-cs-inv1}
\end{table}

Let us consider an example of the two equations: \verb!eq a = b .! \verb!eq a = c .!
% \begin{small}
% \begin{verbatim}
% eq a = b .  eq a = c .
% \end{verbatim}
% \end{small}
From the two equations, $a$, $b$ and $c$ are equal in equational logic point of view, however, $a$ rewrites to either $b$ or $c$ with rewriting. 
% CafeOBJ may rewrite \verb!a! to \verb!b!, while CafeInMaude may rewrite \verb!a! to \verb!c!. The behaviors of CafeOBJ and CafeInMaude are different if some equations, such as a = b, are used in a module and some equations, such as a = c, are used in an open-close fragment that uses the module. 
Thus it is impossible to prove that all of $a$, $b$ and $c$ are equal only by rewriting when the specification (or term rewriting systems) is non-confluent. If we revise the two equations:
% \begin{small}
% \begin{verbatim}
\verb!eq a = b .! \verb!eq b = c .!
% \end{verbatim}
% \end{small}
we can prove that all of $a$, $b$ and $c$ are equal only by rewriting. CafeOBJ, Maude and CafeInMaude do not use any completion techniques. Even if CafeOBJ and CafeInMaude return true for each open-close fragment of a proof score, CiMPG may not correctly handle this kind of situation. This is because of the different behaviors of CafeOBJ and CafeInMaude. Rewriting is a sound implementation of equational reasoning but not a perfect implementation of equational reasoning. Therefore, we need to take care of this kind of situation when writing proof scores whose results depend on implementation, such as CafeOBJ, CafeInMaude and CiMPG.

We consider a concrete example corresponding to the induction case \verb!sfin! in inv7 below,
% \begin{small}
\begin{verbatim}
eq pms(a,b,s) = pms(epms(m4)) .    eq a = dst(m2) .
\end{verbatim}
% \end{small}
\noindent
the first equation says that the left hand side rewrites the right hand side. The second equation says that \verb!a! rewrites \verb!dst(m2)!. 
\verb!pms(a,b,s)!, \verb!pms(dst(m2),b,s)!, and \verb!pms(epms(m4))! are semantically equal in equational logic, not by rewriting. 
Although we declare the second equation, \verb!pms(dst(m2),b,s)! can not be rewritten into \verb!pms(a,b,s)! due to the order of equation. Instead of declaring two equations above, thus, the equation should be: \verb!eq pms(dst(m2),b,s) = pms(epms(m4)) .! There are many cases in which we need to revise the proof scores by changing the order of the equations if necessary.
Let us take one open-close fragment from the induction case of inv13 as follows:
% \begin{small}
\begin{verbatim}
open INV .
  op p : -> Protocol .  ops a b b1 p1 p2 : -> Prin .
  ops r1 r2 : -> Rand . op l : -> ListOfChoices .
  op c : -> Choice .    op i : -> Sid . op s : -> Secret .    
  op k : -> PubKey .    op esfin1 : -> EncSFin .
  eq esfin1 \in cesfin(nw(p)) = true .
  eq esfin1 = esfin(k(b,pms(a,b,s),r1,r2),
  sfin(a,b,i,l,c,r1,r2,pms(a,b,s))) .
  eq a = intruder . eq a = p1 . eq b = intruder .
  eq b = p2 .       eq b1 = intruder . 
  red inv13(p,a,b,b1,r1,r2,l,c,i,s,k) implies
  inv13(fakeSfin1(p,p2,p1,esfin1),a,b,b1,r1,r2,l,c,i,s,k) .
close
\end{verbatim}
% \end{small} 
By the time we run the above proof score fragment in CafeInMaude, it returns true, however, CiMPG could not generate correct proof script for this case. Note that CiMPG shows the errors in generated proof scripts, but it can not automatically correct them. We then revise the proof score by removing the last five equations in the above proof passage and CiMPG could generate the correct proof script for this time. We learn from this case that all equations used in open-close fragment are not necessary for CiMPG even if the term is reduced to true in CafeOBJ and/or CafeInMaude. While proof scores are flexible to write, they are subject to human errors since we can overlook some cases during the verification. 

While we were revising the one induction case (sfin) of inv7, we have encountered a situation in which the term cannot be reduced to true. Adding case-splitting by equations and/or using induction hypothesis as the premise of the implication did not work for this case. This is because the module lacks information on the messages in the network indicating one lemma is missing in the existing proof scores. Thus, we need to include this information by means of equations in the specification.
Then we define a trivial lemma as follows; 
% \begin{small}
\begin{verbatim}
op lm1 : Msg Msg Network -> Bool
eq lm1(M, M2, NW) = (M = M2 and M \in NW) implies (M2\in NW) .
\end{verbatim}
% \end{small}	
The equation says that there exists a message \verb!M! in the network and if \verb!M2! message is equivalent to \verb!M!, then \verb!M2! is also in the network. This lemma was used in the above case. Moreover, we need to use the lemma in some induction cases of some invariants such as inv8, inv12, inv13, inv14, inv16, inv17 and inv18. Therefore, it can be said that the formal verification could not be successfully completed without this lemma.
% You should make sub-sections such that each sub-section is dedicated to one contribution that is a tip of use of CiMPG and CiMPA.

% Our purpose is to formally verify the properties of the protocol with the use of CiMPG and CiMPA.
% However, we need to make some modifications to the existing proof scores with CiMPG [cite{twmon} so that the proof scores can be run successfully in CafeInMaude environment and CiMPG can generate the correct proof scripts from proof scores for CiMPA. While we revise the existing proof scores, there are many cases in which we need to conduct the case splittings by introducing equations and/or use other properties as lemma to strengthen the inductive hypothesis many times. Moreover, we revise/write the proof scores for five properties (inv12, inv13, inv16, inv17 and inv18) by induction on the number of transitions applying some tips on writing proof scores in the CafeOBJ method \cite{Ogata2006}.

% The revised proof scores are feed into CafeInMaude and if all proof scores are reduced to \verb!true! then the corresponding properties are proved. If they are not directly reduced to \verb!true!, case splitting or using lemma is required. Even if CafeInMaude returns \verb!true! for each open-close fragment of a proof score, CiMPG may not successfully generate proof scripts from the proof score. In such case, we need to revise the proof score again. If all proof scores are complete, we are ready to use CiMPG to formally verify the properties. In order to use CiMPG, we slightly need to annotate the proof scores. Let us use one example of proof score open-close fragment that is annotated to use CiMPG. The following proof fragment is a proof fragment of one case from inv13
% It is necessary to annotate each open-close fragment of proof
% scores so that proof scores can be handled by CiMPG. Let us take
% one open-close fragment annotated from the proof score of inv13:
% \begin{small}
% \begin{verbatim}
% open INV .
%   :id(tls)
%   op p : -> Protocol .  ops a b b1 : -> Prin .
%   ops r1 r2 : -> Rand . op l : -> ListOfChoices .
%   op c : -> Choice .    op i : -> Sid .
%   op s : -> Secret .    op k : -> PubKey .
% -- arbitrary objects
%   ops p1 p2 : -> Prin . op esfin1 : -> EncSFin .
% -- assumptions
%   eq esfin1 \in cesfin(nw(p)) = true .
%   eq esfin1 = esfin(k(b,pms(a,b,s),r1,r2),
%   sfin(a,b,i,l,c,r1,r2,pms(a,b,s))) .
%   eq a = intruder . eq a = p1 . eq b = intruder .
%   eq b = p2 .   eq b1 = intruder . 
%   red inv13(p,a,b,b1,r1,r2,l,c,i,s,k) implies
%   inv13(fakeSfin1(p,p2,p1,esfin1),a,b,b1,r1,r2,l,c,i,s,k) .
% close
% \end{verbatim}
% \end{small}
% where all the constants except for intruder denote arbitrary
% values of the intended sorts. For example, a, b, b1, p1 and p2 denote arbitrary values of sort Prin. Moreover, we need to add one more open-close fragment to the proof scores, which is as follows:
% where :id(tls) is the annotation. CiMPG treats all open-close fragments annotated by :id(tls) for formal verification of TLS. Each proof score needs to have one special open-close fragment:
% \begin{small}
% \begin{verbatim}
% open INV
%   :proof(tls)
% close
% \end{verbatim}
% \end{small}
% where \verb!tls! is just an identifier, can be replaced by another preferred one. Feeding the annotated proof scores into CiMPG, CiMPG automatically generates the proof script for CiMPA. Feeding the generated proof script into CiMPA, if CiMPA discharges all goals, confirming that the proof scores are correct. 
% Each proof score is stored in a file. The special open-close
% fragment informs CiMPG that the open-close fragments in the file
% all of which are supposed to be annotated by :proof(tls) are to
% be handled by CiMPG.

% \textbf{TO REVISE THIS PART}
% 3. Even though CiMPG suggests how to correct them but you can guess how to fix the errors from the information given by CiMPG.

% CiMPG+F may be able to fix the errors automatically or suggest you how to fix the errors.

% 4. If CiMPG did not fix the errors, you should write how you fixed the errors based on the information given by CiMPG.

% It does not enough to show the revised open-close fragment.
% Before feeding the generated proof scripts from CiMPG into CiMPA, we need to check whether the generated proof scripts contain the errors since there is a situation that CiMPG may not generate proof scripts correctly when the proof scores are not correct. CiMPG generates a formal proof script when the proof score are correct and complete. We describe some examples on how to revise the proof scores so as to generate the correct proof scripts from proof scores by CiMPG. As an example, by the time we run the above proof score fragment with CiMPG, the generated proof script contains the errors indicating that the proof score is not correct. We then need to carefully take a look at the proof score and revise it accordingly by the indicated errors. Note that CiMPG points out the errors in generated proof scripts, but it does not suggest how to fix them. We remove some unnecessary equations/case splitting in the above proof passage and feed the revised proof passage into CafeInMaude to check whether it returns true or not. The revised one for the above proof fragment is as follows:
% \begin{small}
% \begin{verbatim}
% open INV .
%   :id(tls)
%   op p : -> Protocol .  ops a b b1 : -> Prin .
%   ops r1 r2 : -> Rand . op l : -> ListOfChoices .
%   op c : -> Choice .    op i : -> Sid .
%   op s : -> Secret .    op k : -> PubKey .
% -- arbitrary objects
%   ops p1 p2 : -> Prin . op esfin1 : -> EncSFin .
% -- assumptions
%   eq esfin1 \in cesfin(nw(p)) = true .
%   eq esfin1 = esfin(k(b,pms(a,b,s),r1,r2),
%   sfin(a,b,i,l,c,r1,r2,pms(a,b,s))) .
%   eq a = intruder .
% red inv13(p,a,b,b1,r1,r2,l,c,i,s,k) implies
% inv13(fakeSfin1(p,p2,p1,esfin1),a,b,b1,r1,r2,l,c,i,s,k) .
% close
% \end{verbatim}
% \end{small}
% The revised annotated proof fragment is fed into CiMPG and CiMPG, unfortunately can not generate the correct proof script for this proof score
% % , there is still an error in the scripts 
% letting us know that the proof score is still not good enough for CiMPG to generate the correct proof script and pointing out that using the equation \verb!a = intruder! for case splitting is not correct. Then we revise the proof score by removing that equation and feed the proof score into CiMPG. This time CiMPG can handle this case and generates the correct proof script. The revised proof score is as follows:
% \begin{small}
% \begin{verbatim}
% open INV .
%   :id(tls)
%   op p : -> Protocol .  ops a b b1 : -> Prin .
%   ops r1 r2 : -> Rand . op l : -> ListOfChoices .
%   op c : -> Choice .    op i : -> Sid .
%   op s : -> Secret .    op k : -> PubKey .
% -- arbitrary objects
%   ops p1 p2 : -> Prin . op esfin1 : -> EncSFin .
% -- assumptions
%   eq esfin1 \in cesfin(nw(p)) = true .
%   eq esfin1 = esfin(k(b,pms(a,b,s),r1,r2),
%   sfin(a,b,i,l,c,r1,r2,pms(a,b,s))) .
% red inv13(p,a,b,b1,r1,r2,l,c,i,s,k) implies
% inv13(fakeSfin1(p,p2,p1,esfin1),a,b,b1,r1,r2,l,c,i,s,k) .
% close
% \end{verbatim}
% \end{small}
% CiMPG could generate the correct proof scripts for CiMPA this time.
% Although writing proof scores is flexible to conduct formal verification, the verification may contain some flaws because proof scores are subject to human errors.
% Human users can overlook some cases during the revision of the proof scores because several case splittings are in general possible for each goal. From this example, we experience that we do not need to introduce the equations unnecessarily even though CafeInMaude returns true for this proof passage. 
% Let us consider the following proof passage corresponding to case sfin2 of inv6:
% \begin{small}
% \begin{verbatim}
% open INV .
%   op p : -> Protocol .  ops a b : -> Prin .
%   ops r1 r2 : -> Rand . op c : -> Choice .
%   op i : -> Sid .       op s : -> Secret .
% -- arbitrary objects
%   op p2 : -> Prin . ops m1 m2 m3 : -> Msg .
% -- assumptions
%   eq m1 \in nw(p) = true .  eq m2 \in nw(p) = true .
%   eq m3 \in nw(p) = true .  eq ch2?(m1) = true .
%   eq sh2?(m2) = true .      eq cf2?(m3) = true .
%   eq crt(m2) = p2 .         eq src(m2) = p2 .
%   eq src(m1) = dst(m2) .    eq dst(m1) = p2 .
%   eq src(m3) = dst(m2) .    eq dst(m3) = p2 .
%   eq sid(m1) = sid(m2) .
%   eq (ss(p,dst(m2),p2,sid(m2)) = none) = false .
%   eq choice(ss(p,dst(m2),p2,sid(m2))) = choice(m2) .
%   eq ecfin2(m3) = ecfin2(k(dst(m2),pms(ss(p,dst(m2),p2,
%   sid(m2))),rand(m1),rand(m2)),cfin2(dst(m2),p2,sid(m2),
%   choice(m2),rand(m1),rand(m2),pms(ss(p,dst(m2),p2,sid(m2))))) .
%   eq r1 = rand(m1) .    eq a = dst(m2) .    eq i = sid(m2) .
%   eq c = choice(m2) .   eq b = p2 . eq r2 = rand(m2) .
%   eq (pms(ss(p,dst(m2),p2,sid(m2))) = pms(a,b,s)) = false .
%   eq pms(ss(p,dst(m2),p2,sid(m2))) = pms(dst(m2),p2,s) .
%   eq dst(m2) = intruder .
%   red inv6(p,a,b,r1,r2,c,i,s) implies
%   inv6(sfin2(p,p2,m1,m2,m3),a,b,r1,r2,c,i,s) .
% close
% \end{verbatim}
% \end{small}
% The above proof passage corresponds to a (sub-) case obtained by splitting the induction case for \verb!sfin2!. CafeInMaude returns \verb!true! for the proof passage, however CiMPG can not generate the correct proof script for the equation 
% % In each open-close fragment, several equations are added, and then the extended specifications (the original specification + the open-close fragment) often becomes non-confluent. Even so, CafeInMaude returns true and CiMPG can successfully generate correct proof spirits for the open-close fragment. You need to investigate that every non-confluent extended specification cannot be successfully handled by CiMPG or only some cannot. If this is the latter case, you need to investigate what type of non-confluent (what type of equations) cause errors by CiMPG.
% % It is not enough to use a concrete example to explain it.
% \verb!eq pms(ss(p,dst(m2),! \verb!p2, sid(m2))) = pms(a,b,s) .!
% since we have the equation \verb!eq a = dst(m2) .! and \verb!a! rewrites to \verb!dst(m2)!, not vice versa. Hence, the equation should be \verb!eq pms(ss(p,dst(m2),! \verb!p2, sid(m2))) = pms(dst(m2),p2,s) .! Then we revise the proof fragment as follows:
% \begin{small}
% \begin{verbatim}
% open INV .
%   op p : -> Protocol .  ops a b : -> Prin .
%   ops r1 r2 : -> Rand . op c : -> Choice .
%   op i : -> Sid .       op s : -> Secret .
% -- arbitrary objects
%   op p2 : -> Prin . ops m1 m2 m3 : -> Msg .
% -- assumptions
%   eq m1 \in nw(p) = true .  eq m2 \in nw(p) = true .
%   eq m3 \in nw(p) = true .  eq ch2?(m1) = true .
%   eq sh2?(m2) = true .      eq cf2?(m3) = true .
%   eq crt(m2) = p2 .         eq src(m2) = p2 .
%   eq src(m1) = dst(m2) .    eq dst(m1) = p2 .
%   eq src(m3) = dst(m2) .    eq dst(m3) = p2 .
%   eq sid(m1) = sid(m2) .
%   eq (ss(p,dst(m2),p2,sid(m2)) = none) = false .
%   eq choice(ss(p,dst(m2),p2,sid(m2))) = choice(m2) .
%   eq ecfin2(m3) = ecfin2(k(dst(m2),pms(ss(p,dst(m2),p2,
%   sid(m2))),rand(m1),rand(m2)),cfin2(dst(m2),p2,sid(m2),
%   choice(m2),rand(m1),rand(m2),pms(ss(p,dst(m2),p2,sid(m2))))) .
%   eq r1 = rand(m1) .    eq a = dst(m2) .    eq i = sid(m2) .
%   eq c = choice(m2) .   eq b = p2 . eq r2 = rand(m2) .
%   eq pms(ss(p,dst(m2),p2,sid(m2))) = pms(dst(m2),p2,s) .
%   red inv6(p,a,b,r1,r2,c,i,s) implies
%   inv6(sfin2(p,p2,m1,m2,m3),a,b,r1,r2,c,i,s) .
% close
% \end{verbatim}
% \end{small}

% Let us consider an another concrete example of the following two equations:
% \begin{small}
% \begin{verbatim}
% eq a = b .  eq a = c .
% \end{verbatim}
% \end{small}
% From the two equations, a, b and c are equal in equational logic point of view, however, \verb!a! rewrites to either \verb!b! or \verb!c! with rewriting.
% CafeOBJ may rewrite \verb!a! to \verb!b!, while CafeInMaude may rewrite \verb!a! to \verb!c!. The behaviors of CafeOBJ and CafeInMaude are different if some
% equations, such as a = b, are used in a module and some equations, such as a = c, are used in an open-close fragment that uses the module. Thus it is impossible to prove that all of a, b and c are equal only by rewriting when the specification (or term rewriting systems) is non-confluent.
% If we revise the two equations as follows:
% \begin{small}
% \begin{verbatim}
% eq a = b .  eq b = c .
% \end{verbatim}
% \end{small}
% we can prove that all of a, b and c are equal only by rewriting. CafeOBJ, Maude and CafeInMaude do not use any completion techniques. Even if CafeOBJ and CafeInMaude return true for each open-close fragment of a proof
% score, CiMPG may not correctly handle this kind of situation. This is because of the different behaviors of CafeOBJ and CafeInMaude. Rewriting is a sound implementation of equational reasoning but not a perfect implementation of equational reasoning. Therefore, we need to take care of this kind of situation when writing proof scores whose results depend on implementation, such as CafeOBJ, CafeInMaude and CiMPG.

In this section, we have described how to revise the existing proof scores with some example cases and one missing lemma. When we revise the existing proof scores, each step is not straightforward because many case splittings are possible and many implications and instantiations can be used.
Some lessons learned from revising proof scores are (1) in order to utilize CiMPG, we need to get rid of semantic-based case splittings, (2) the order of the declaration of the equation matters in term rewriting, (3) the result of the reduction depends on the implementation of the system, (4) even if CafeOBJ and CafeInMaude return true for the proof score, CiMPG may not correctly handle some kinds of situation meaning that the proof score is not good enough or it contains an error. We will present in the next section how to use CiMPG for existing large proof scores.

\section{A Way to Use CiMPG for Existing Large Proof Scores}\label{fvtls}
This section describes how existing large proof scores are tackled by CiMPG in which ways. The formal verification can be conducted by writing manual proof scripts with CiMPA. The proof scripts are reliable, but they are not easy to develop, especially with non-expert users. Writing proof scripts manually is not a good idea for the protocols whose size of the proof scores is large. Moreover, CiMPA is easy to choose an erroneous order for the case distinctions, generating more goals than required. Thus, we prefer to use CiMPG to automatically generate the proof scripts from proof scores. On the other hand, CiMPG takes time to generate the proof script when the size of the proof score is large. In this case study, we first tackle each invariant with CiMPG one by one instead of tackling all proof scores at the same time since the size of all proof scores is huge. Actually, the proof score for each invariant is quit complex and large. By conducting one invariant by one, it is easier to check the errors in the generated proof scripts corresponding to each invariant and makes us understandable/guessable the cause of errors and then we can revise the proof scores in appropriate way. We use three devices (two MacBook Air that carry 1.6 GHz Intel Core i5 processor, 16 GB memory and one MacBook Pro that carries 2.3 GHz Quad-Core Intel Core i7 processor, 32 GB memory) to conduct this case study running the programs in parallel so as to complete the formal verification faster. We describe in next sections how CiMPG handles the large existing proof scores to successfully complete the formal verification. 

\subsection{How to handle each proof score one by one with CiMPG}\label{eachpf}
% Taking a look at the following two equations corresponding to the induction case \verb!sfin! in \verb!inv7! below,
% \begin{small}
% \begin{verbatim}
% eq pms(a,b,s) = pms(epms(m4)) . eq a = dst(m2) .
% \end{verbatim}
% \end{small}
% the first equation says that the left hand side rewrites the right hand side. The second equation says that \verb!a! rewrites \verb!dst(m2)!. When we declare the second equation, it does not rewrite \verb!a! into \verb!dst(m2)! in \verb!eq pms(a,b,s)!. Instead, the equation should be: \verb!eq pms(dst(m2),b,s) = pms(epms(m4)) .! There are many cases in which we need to revise the proof scores by changing the order of the equations if necessary.
Each invariant is tackled with CiMPG one by one in this approach. We use the current version of CafeInMaude. \footnote{\url{https://github.com/ariesco/CafeInMaude}}
This version supports parallel execution not in the old version. However, behavioral specifications are not supported. We create a command file with .cafe extension for each invariant. Each command file contains the commands for loading the modules, inferring the proof without proof scores, generating the proof, saving the proof, and loading the proof, etc. The following is the cmd4.cafe file with the commands for inv4:
% \begin{small}
	\begin{verbatim}
load ../examples/CCiMPG/TLS-old/tls.cafe .
load ../examples/CCiMPG/TLS-old/inv4.cafe .
set-cores 4 .
set-output ../examples/CCiMPG/TLS-old/gen4.cafe .
:proven(inv1(P:Protocol, PMS:Pms))
:infer-proof inv4 .
:save-proof .
	\end{verbatim}
% \end{small}
where load command executes the input stored in the file located at the given path. The cmd4.cafe file can be loaded by \verb!load ../examples/CCiMPG/TLS-old/cmd4.cafe .! Then CafeInMaude executes the commands in the file one by one. The specification of TLS is stored in tls.cafe and the file is loaded by first load command. The second load command loads the proof related to the invariant. The set-cores command indicates that how many processes are used for concurrent computation. The set-output command sets the file for storing generated proofs. We can infer the proof using the command :infer-proof followed by the identifier which is named in the open-close environments in the proofs. The :save-proof command stores the current proof in the file previously indicated by means of set-output. After the generation of the proofs is complete, we load the file which stored the generated proofs using the load command. If we see PROOF FINISHED! comment after some time, then it can be said that CiMPA discharges all goals, confirming that the proof scores are correct and the formal verification for this invariant is successfully done. Similarly, we would do the same way for all invariants.
	
CiMPG takes generally from 8 to 9 hours to generate the proof scripts for each invariant in both devices, however it takes 52 hours and 17 minutes for 
% running all inductive cases in one file for 
inv17 using MacBook Pro. The inv7 has 297 open–close proof fragments involving more than 8000 lines of code. Since the size of the proof scores is quite large, CiMPG took long time to generate the proof script. We come up with an idea to divide the proof scores into smaller size
% open-close fragments when the proof scores is too big to be tackled by CiMPG
so that CiMPG can generate the proof scripts from scores in a reasonable amount of time. 

\subsection{How to handle each induction case one by one with CiMPG} \label{eachinduction}
The proof scores of inv17 is divided into each induction case with the base case and feed into CiMPG using the same environment. The way how to handle this approach with CiMPG is exemplified using the induction case \verb!chello! of inv17 as follows: 
\begin{verbatim}
open INV .
:id(inv17)
ops a b b1 b2 b3 : -> Prin .  ops r1 r2 : -> Rand .
op l : -> ListOfChoices . op c : -> Choice .
op i : -> Sid .  op s : -> Secret .  op k : -> PubKey .
red inv17(init,a,b,b1,b2,b3,r1,r2,l,c,i,s,k) .
close
open INV .
:id(inv17)
op p : -> Protocol .    op c : -> Choice .  
ops a b b1 b2 b3 p1 p2 : -> Prin .   
ops r1 r2 r3 : -> Rand .  op l l1 : -> ListOfChoices .   
op i : -> Sid . op s : -> Secret .  op k : -> PubKey .
eq (r3 \in ur(p)) = true .
red inv17(p,a,b,b1,b2,b3,r1,r2,l,c,i,s,k) implies inv17
(chello(p,p1,p2,r3,l1),a,b,b1,b2,b3,r1,r2,l,c,i,s,k) .
close
open INV .
:id(inv17)
op p : -> Protocol .    op c : -> Choice .  
ops a b b1 b2 b3 p1 p2 : -> Prin .   
ops r1 r2 r3 : -> Rand .  op l l1 : -> ListOfChoices .   
op i : -> Sid . op s : -> Secret .  op k : -> PubKey .
eq (r3 \in ur(p)) = false .
red inv17(p,a,b,b1,b2,b3,r1,r2,l,c,i,s,k) implies inv17
(chello(p,p1,p2,r3,l1),a,b,b1,b2,b3,r1,r2,l,c,i,s,k) .
close
\end{verbatim}
The open-close fragments above are the proofs related to the case chello with the base case; they are stored in chello.cafe file. Then what we have to do is similar to what we have described in the subection \ref{eachpf}. We then create a cmd-chello.cafe file which contains the following commands:
% \begin{small}
\begin{verbatim}
load ../examples/CCiMPG/TLS-old/exp-12-20/tls.cafe .
load ../examples/CCiMPG/TLS-old/exp-12-20/chello.cafe .
set-output ../examples/CCiMPG/TLS-old/exp-12-20/gen-chel
lo.cafe .
:infer-proof inv17 .    :save-proof .
\end{verbatim}
% \end{small}
The above file is loaded by \verb!load ../examples/CCiMPG/TLS-old/!
\verb!exp-12-20/cmd-chello.cafe .! The first load command loads the specification of the protocol. The second one loads the proof related to the induction case chello. The set-output command sets the file for storing generated proofs. The proof is inferred using :infer-proof followed by the identifier which is named in the open-close environments in the proofs. The :save-proof command stores the generated proof in the gen-chello.cafe file. Similarly, we apply the same way for other induction cases. The time taken for generating proof script for each induction case one by one with CiMPG is collected in table \ref{tab:tb3.1}. CiMPG takes 16 hours, 10 minutes and 58 seconds in total for all induction cases of inv17. Table \ref{tab:tb3.2} shows the time taken for generating proof scripts for all induction cases in one file at the same time. Comparing the time taken by different approaches in two tables, we can see the positive result that CiMPG reduces the run time by handling each induction case one by one. Therefore, this method is one possible way to reduce the time taken in dealing the large size of proof score with CiMPG for formal verification. 
\newline
\begin{table}[]
% \begin{subtable}
\begin{tabularx}{0.48\textwidth} { 
  | >{\centering\arraybackslash}X 
  | >{\centering\arraybackslash}X
  | >{\centering\arraybackslash}X
  | >{\centering\arraybackslash}X| }
 \hline
 inductive case & runtime (h:m:s) & inductive case & runtime (h:m:s) \\
 \hline
 cert & 0:01:30 & fakeKexch1 & 0:00:17 \\
 \hline
 cfin & 0:14:27 & fakeKexch2 & 0:00:26 \\
 \hline
 cfin2 & 0:03:15 & fakeSfin1 & 0:05:46 \\
 \hline
 chello & 0:00:22 & fakeSfin2 & 0:02:02 \\
 \hline
 chello2 & 0:00:01 & fakeSfin21 & 0:00:13 \\
 \hline
 compl & 0:53:55 & fakeSfin22 & 0:00:01 \\
 \hline
 compl2 & 0:19:18 & fakeShello & 0:11:09 \\
 \hline
 fakeCert & 0:21:02 & fakeShello2 & 0:00:01 \\
 \hline
 fakeCfin1 & 0:00:01 & kexch & 0:06:42 \\
 \hline
 fakeCfin2 & 0:00:14 & sfin & 13:41:00 \\
 \hline
 fakeCfin21 & 0:00:01 & sfin2 & 0:06:29 \\
 \hline
 fakeCfin22 & 0:00:08 & shello & 0:02:10 \\
 \hline
 fakeChello & 0:00:01 & shello2 & 0:00:26 \\
 \hline
 fakeChello2 & 0:00:01 & \textbf{Total} & 16:10:58\\
 \hline
\end{tabularx}
\caption{Runtime for each inductive case of inv17}
\label{tab:tb3.1}
% \end{subtable}
\hfill
% \begin{table}[]
% \begin{subtable}
\begin{tabularx}{0.48\textwidth} { 
  | >{\centering\arraybackslash}X 
  | >{\centering\arraybackslash}X|
 }
 \hline
 all in one & runtime (h:m:s) \\
 \hline
 inv17 & 52:17:18 \\
 \hline
\end{tabularx}
\caption{Runtime for all inductive cases of inv17 in one file}
\label{tab:tb3.2}
% \end{subtable}
% \caption{Runtime for each inductive case one by one Vs Runtime for all inductive cases at the same time for inv17}
% \label{tab:tb3}
\end{table}



\section{Related Work}\label{relatedwork}
From a CafeOBJ specification and an invariant property,
while CiMPG requires complete proof scores of the property to generate correct proof scripts,
CiMPG+F \cite{Riesco20}, which is another tool implemented on top of CafeInMaude,
can infer proof scripts even some proof score fragments are missing.
Precisely, CiMPG+F can (i) generate complete proof scripts from scratch and (ii) fix incomplete proof scores.
Human users need to introduce invariant properties to be proven and the variable on which structural induction is used.
When the proof scores provided are incomplete, CiMPG+F tries to fix it by using the given information to prune the search space.
Furthermore, when proof scripts cannot be generated from scratch, human users can provide a (partial) proof score guiding the process; in this way, CiMPG+F is in charge of the mechanical work and leaves human users the creative tasks.
The paper \cite{Riesco20} have reported experiments with several protocols, such as NSLPK, showing that CiMPG+F can completely generate proof scripts for all case studies.
TLS case study, whose formal specification is more complicated than all case studies used in the paper, is not tackled.

%The implementation of CiMPG+F employs some Maude meta-level functionalities, such as the built-in function \verb!metaReduce! to reduce a term to canonical form.
%An essential problem in the implementation of CiMPG+F is how to conduct case splitting.

There is a large number of tools existing for automatically verifying cryptographic protocols such as ProVerif \cite{proverif}, Maude-NPA \cite{maudenpa}, Tamarin \cite{tamarin}, and Scyther \cite{Scyther08}.
ProVerif can automatically prove security properties of cryptographic protocol specifications.
The tool is based on an abstract representation of the protocol by a set of Horn clauses,
and it determines whether the desired security properties hold by resolution on these clauses.
The practicability of ProVerif has been demonstrated through case studies in \cite{proverif2} and \cite{proverif3}. 
ProVerif can handle an unbounded number of sessions (executions) of protocols. 
% but termination is not guaranteed in general because the resolution algorithm may not terminate. 
However, the full automatic of ProVerif comes at a cost, that is, termination is not guaranteed in general because the resolution algorithm may not terminate. 
%the number of sessions (executions) of protocols may be unbounded. 

Maude-NPA \cite{maudenpa} is a tool for reasoning about the security of cryptographic protocols in which cryptosystems satisfy different equational properties.
The tool can handle searches in the unbounded session model, and thus can be used to provide proofs of security as well as to search for attacks.
The most challenging problem is how to deal with a huge or even infinite state space.
To mitigate this challenge, Escobar et al. \cite{maudenpa08} have proposed some techniques to reduce the size of the search space, such as generating formal grammars representing terms (states information) unreachable from initial states and using super lazy intruder to delay the generation of substitution instances as much as possible.
Even though, the termination of the tool is not always guaranteed.
% Many case studies have been presented to demonstrate the practicability of Maude-NPA, such as ...
%TODO: search for some case studies and add them here

Scyther \cite{Scyther08} is an another tool for security verification of cryptographic protocols.
Like ProVerif, Scyther also supports an unbounded number of sessions, but it supports only a fixed set of cryptographic primitives (symmetric and asymmetric encryption and signatures) and does not allow for user-specified equational theories.
Its successor, namely Tamarin prover \cite{tamarin} supports equational theories.
Moreover, Tamarin  provides the two ways of constructing proofs: fully automated mode and interactive mode. 
The tool may not terminate in the fully automated mode.
In the interactive mode, the tool allows users to provide lemmas that must be proved. 
Of course, finding suitable lemmas is an intellectual task, which is not novel in the field of formal verification.
% Some case studies on security analysis of cryptographic primitives and protocols with Tamarin are ...
%TODO: search for some case studies and add them here

Ogata and Futatsugi \cite{1437139} have formally verified TLS 1.0 handshake protocol  with the proof score approach \cite{OgataF03fmoods}.
As we have already mentioned, writing proof scores by hand is prone to human errors even though it is flexible to do so.
Paulson \cite{Paulson99} has also analyzed TLS 1.0 handshake protocol  with his inductive method \cite{Paulson98}.
The verification, which was tackled with the proof assistant Isabelle/HOL \cite{NipkowPW02}, also confirmed the security of the protocol.
On the other hand,
Bhargavan et al. \cite{BhargavanFCZ12} have claimed that using some formal specification languages to specify cryptographic protocols often lacks details.
Thus, they have verified detailed cryptographic implementation of TLS 1.0.
%They claimed that using some formal specification languages to specify cryptographic protocols often lacks details.
%They then proposed  to verify detailed protocol implementations and deployments.
Their verification method consists of selecting a part of the implementation and writing additional verification harness code that specifies the attacker model, the cryptographic
assumptions, and the target security properties, and then compiling their combination to ProVerif \cite{proverif}. 
An advantage of the approach is that we can easily re-verify the code after a revision (like regression testing) because the verification tool chain is automated.
The automation, however, comes at a cost: in some cases, especially with a complicated implementation,
the verifier may not terminate; in others, it may take a huge amount of memory.


% The paper ~\cite{spin} used the model checking method to formally verify security protocols using Spin model checker. The paper exampled NSPK protocol and DS protocol. The experimental results showed that
% the number of the protocol model states has been decreased
% by a wide margin, and the efficiency of protocol verification has been improved properly. The security protocol models mainly include the protocol
% instance model and the intruder model. It is described with Promela Model. The property of security protocols is described using LTL. An attack is found in each protocol. The difference between their method and our method is that we use OTS/CafeOBJ method to formalize the protocols as state machines. The Dolev-Yao intruder model is used in both methods. Furthermore, this paper only verified the authentication property of security protocols while we verified authentication and secrecy properties.

% Mitchell, et al.[7] use the model checker Mur [3] to
% check seven simple protocols derived from the SSL 3.0
% handshake protocol. The primal reason why they have analyzed
% the protocols is to identify the purpose of certain message
% fields (version number, nonce, etc.) in some steps of
% the protocol. The analysis starts with the simplest version of
% the handshake protocol from which some fields are omitted,
% and the fields are gradually added to the protocol. The first
% six protocols have been found badly flawed and the model
% checker has found many attacks. The model checker has
% been used to check the final protocol with two clients, one
% server, no more than two simultaneous open sessions per
% server and no more than one resumption per session, and no
% attacks have been discovered.

% Paulson[11] analyzes the TLS handshake protocol with
% his inductive method[10] that is supported by the proof assistant
% Isabelle/HOL[8]. In the protocol analyzed by Paulson,
% servers always sent their certificates to clients, the key exchange method considered is RSA, and clients optionally
% send their certificates and ClientKeyExchange messages to
% servers. In his model of the protocol, a malicious principal
% called the spy, which corresponds to the intruder in our
% model, is taken into account and it is supposed that any session
% key, if used, may end up in the hands of the spy, which
% is denoted by the rule Oops. One of the results of the analysis
% is that session resumption turns out to be safe even if the
% spy has obtained session keys from earlier sessions.

% Palombo, et al. \cite{Palombo2015ACS} have formally analyzed several examples of a particular class of cryptographic protocols (NSPK, DS, TMN, and DH) using three alternative tools. They used SPIN to analyze explicit state models written in Promela; symbolic models in the pi-calculus were verified using Proverif, and finally, we proved lemmas that show protocol insecurity using the theorem prover Coq. They have presented that choosing the right tool always implies a trade-off. It is generally easier to model a system using SPIN’s state representation than using the pi-calculus or
% logical inference rules. However, SPIN can only verify a bounded number of sessions and
% message space. Proverif verifies an unbounded number of sessions and message space at the cost of potentially not terminating or reporting false attacks. On the other hand, Coq theories with security proofs are not bounded and can
% represent an unrestricted symbolic attacker. They have shown that protocol insecurity can be
% proved in Coq. On the other hand, proof that demonstrates that the properties hold may be harder to construct. In comparison with our research, we proved lemmas that show protocol security using proof assistant CiMPA and proof generator CiMPG.

\section{Conclusion}\label{conclusion}
This paper has presented a case study on the formal verification of TLS 1.0 handshake protocol. The protocol has been formally verified with CiMPG and CiMPA. The main proof technique used is (simultaneous) structural induction on reachable states. We have used the existing proof scores and we needed to revise the proof scores so that CiMPG can handle them. To formally verify that TLS 1.0 enjoys the properties, we have used several lemmas including the one lemma that we found during the formal verification. CiMPG often takes time to generate proof scripts from the proof scores when the size of input proof scores is huge. It is not reasonable to handle all proof scores at the same time with CiMPG. Thus, we handled each proof score one by one with CiMPG. There is one proof score it took a long time to handle with CiMPG. For the proof score, we handled each induction case one by one to reduce the time taken. We have described how to revise the existing proof scores, the missing lemma, how to handle each proof score one by one, and how to handle each induction case one by one as tips on handling existing large proof scores. One piece of our future work is to formally verify other security protocols with CiMPG confirming the usefulness of the method used in subsection \ref{eachinduction} to reduce the time taken. 
      



% Numbered list
% Use the style of numbering in square brackets.
% If nothing is used, default style will be taken.
%\begin{enumerate}[a)]
%\item 
%\item 
%\item 
%\end{enumerate}  

% Unnumbered list
%\begin{itemize}
%\item 
%\item 
%\item 
%\end{itemize}  

% Description list
%\begin{description}
%\item[]
%\item[] 
%\item[] 
%\end{description}  

% Figure
% \begin{figure}[<options>]
% 	\centering
% 		\includegraphics[<options>]{}
% 	  \caption{}\label{fig1}
% \end{figure}


% \begin{table}[<options>]
% \caption{}\label{tbl1}
% \begin{tabular*}{\tblwidth}{@{}LL@{}}
% \toprule
%   \\ % Table header row
% \midrule
% \\
% \\
% \\
% \\
% \bottomrule
% \end{tabular*}
% \end{table}

% Uncomment and use as the case may be
%\begin{theorem} 
%\end{theorem}

% Uncomment and use as the case may be
%\begin{lemma} 
%\end{lemma}

%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

% There are several ideas/devices that should be used to make the formal
% verification successful.


% To print the credit authorship contribution details
% \printcredits

%% Loading bibliography style file
%\bibliographystyle{model1-num-names}
\bibliographystyle{cas-model2-names}

% Loading bibliography database
\bibliography{cas-refs}

% Biography
\bio{}
% Here goes the biography details.
\endbio

% \bio{pic1}
% % Here goes the biography details.
% \endbio

\end{document}

% 