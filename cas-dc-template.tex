%% 
%% Copyright 2019-2021 Elsevier Ltd
%% 
%% This file is part of the 'CAS Bundle'.
%% --------------------------------------
%% 
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%% 
%% The list of all files belonging to the 'CAS Bundle' is
%% given in the file `manifest.txt'.
%% 
%% Template article for cas-dc documentclass for 
%% double column output.

\documentclass[a4paper,fleqn]{cas-dc}
\usepackage{tabularx}
% If the frontmatter runs over more than one page
% use the longmktitle option.

%\documentclass[a4paper,fleqn,longmktitle]{cas-dc}

\usepackage[numbers]{natbib}
%\usepackage[authoryear]{natbib}
% \usepackage[authoryear,longnamesfirst]{natbib}

%%%Author macros
\def\tsc#1{\csdef{#1}{\textsc{\lowercase{#1}}\xspace}}
\tsc{WGM}
\tsc{QE}
%%%

% Uncomment and use as if needed
%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}[theorem]{Lemma}
%\newdefinition{rmk}{Remark}
%\newproof{pf}{Proof}
%\newproof{pot}{Proof of Theorem \ref{thm}}

\begin{document}

\let\WriteBookmarks\relax
\def\floatpagepagefraction{1}
\def\textpagefraction{.001}

% Short title
\shorttitle{TLS 1.0 handshake protocol formal verification case study}    

% Short author
\shortauthors{Thet Wai Mon, Duong Dinh Tran, Adrian Riesco and Kazuhiro Ogata}  

% Main title of the paper
\title [mode = title]{TLS 1.0 handshake protocol formal verification case study: \\an approach to use of CiMPG and CiMPA for existing large proof scores in CafeOBJ}  

% Title footnote mark
% eg: \tnotemark[1]
\tnotemark[1] 

% Title footnote 1.
% eg: \tnotetext[1]{Title footnote text}
\tnotetext[1]{This work was partially supported by ...} 

% First author
%
% Options: Use if required
% eg: \author[1,3]{Author Name}[type=editor,
%       style=chinese,
%       auid=000,
%       bioid=1,
%       prefix=Sir,
%       orcid=0000-0000-0000-0000,
%       facebook=<facebook id>,
%       twitter=<twitter id>,
%       linkedin=<linkedin id>,
%       gplus=<gplus id>]

% \author[<aff no>]{<author name>}[<options>]
\author[1]{Thet Wai Mon}
% Corresponding author indication
% \cormark[<corr mark no>]

% Footnote of the first author
% \fnmark[<footnote mark no>]

% Email id of the first author
\ead{thetwaimon@jaist.ac.jp}

% URL of the first author
% \ead[url]{<URL>}

% Credit authorship
% eg: \credit{Conceptualization of this study, Methodology, Software}
% \credit{<Credit authorship details>}

% Address/affiliation
\affiliation[1]{organization={School of Information Science, Japan Advanced Institute of Science and Technology (JAIST)},
            addressline={1-1 Asahidai }, 
            city={Nomi},
            postcode={923-1292}, 
            state={Ishikawa},
            country={Japan}}

\author[1]{Duong Dinh Tran}

% Footnote of the second author
% \fnmark[2]

% Email id of the second author
\ead{duongtd@jaist.ac.jp}

\author[2]{Adri{\'{a}}n Riesco}
\ead{ariesco@fdi.ucm.es}
\affiliation[2]{organization={Facultad de Inform{\'{a}}tica, Universidad Complutense de Madrid},
            country={Spain}}
            
% URL of the second author
% \ead[url]{}

% Credit authorship
% \credit{}

\author[1]{Kazuhiro Ogata}

% Footnote of the author
\fnmark[*]

% Email id of the author
\ead{ogata@jaist.ac.jp}

% Address/affiliation
% \affiliation[<aff no>]{organization={},
%             addressline={}, 
%             city={},
% %          citysep={}, % Uncomment if no comma needed between city and postcode
%             postcode={}, 
%             state={},
%             country={}}
% \affiliation[1]{organization={School of Information Science, Japan Advanced Institute of Science and Technology (JAIST)},
%             addressline={1-1 Asahidai }, 
%             city={Nomi},
%             postcode={923-1292}, 
%             state={Ishikawa},
%             country={Japan}}
            
% Corresponding author text
% \cortext[1]{Corresponding author}
% \cortext[2]{Corresponding author}
% Footnote text
\fntext[1]{}

% For a title note without a number/mark
%\nonumnote{}
\maketitle

% Here goes the abstract
\begin{abstract}
TLS 1.0 has been formally verified with CafeInMade Proof Generator (CiMPG) and Proof Assistant (CiMPA), where CafeInMaude is the world's second implementation of CafeOBJ, a direct successor of OJB3, the best-known algebraic specification language. The properties concerned are the secrecy property of pre-master secrets and the correspondence (or authentication) property from both master and client points of view. We need to use several lemmas to formally verify that TLS 1.0 enjoys the properties. CiMPG takes proof scores written in CafeOBJ and generate proof scripts that can be checked by CiMPA. Proof scores are subject to human errors and CiMPG can be regarded as a proof score checker in that if the proof scripts generated by CiMPG from proof scores are successfully checked by CiMPA, it is guaranteed that no human error is lurking in the proof scores. We have used the existing proof scores that TLS 1.0 enjoys the two properties. We needed to revise the proof scores so that CiMPG can handle them. CiMPG made us notice that one lemma was missing, namely that a human error was found by CiMPG. There are about 20 proof scores and each proof score is large. It is not reasonable to handle all proof scores at the same time with CiMPG. Thus, we handled each proof score one by one with CiMPG. There is one proof score it took a long time to handle with CiMPG. For the proof score, we handled each induction case one by one to reduce the time taken. We describe how to revise the existing proof scores, how to find the missing lemma, the lemma, how to handle each proof score one by one, and how to handle each induction case one by one as tips on handling existing large proof scores.
\end{abstract}

% Use if graphical abstract is present
%\begin{graphicalabstract}
%\includegraphics{}
%\end{graphicalabstract}

% Research highlights
% \begin{highlights}
% \item 
% \item 
% \item 
% \end{highlights}

% Keywords
% Each keyword is seperated by \sep
\begin{keywords}
 CiMPG \ CafeInMaude \ invariant \ OTS \ proof scores
\end{keywords}

% Main text
\section{Introduction}\label{intro}
Internet security is extremely crucial nowadays because many kinds of credential information, such as credit card numbers and social security numbers, are transmitted over the Internet. To make such transmission secure, many security protocols have been designed and developed so far. One of the most widely used ones is Transport Layer Security (TLS) \cite{dierk} that is the successor of Secure Sockets Layer (SSL) \cite{*1}. 
% here

TLS consists of multiple sub-protocols one of which is the handshake protocol. The handshake protocol is an authentication protocol, allowing a server and a client to authenticate each other and to securely exchange some security parameters. We suppose that each of servers and clients has been securely given a public-private key pair in this paper. As other authentication protocols, several formal verification case studies \cite{article, 10.1145/3133956.3134063, 10.1145/967900.968063} have been conducted so far. Ogata and Futatsugi \cite{1437139} have formally verified that TLS 1.0 handshake protocol enjoys some desired properties by writing proof scores \cite{OgataF03fmoods} in CafeOJB \cite{DiaconescuF98amast} and executing them with CafeOBJ. 
CafeOBJ is a direct successor of OBJ3, the best-known algebraic specification language, and its system is also referred to as CafeOBJ. Proof scores are proof plans written in an algebraic specification language, such as OBJ3 and CafeOBJ.

Proof scores are to be written by human users and what can be done by CafeOBJ for proof scores is to reduce terms. If each term in proof scores reduces as expected, such as to true, which is supposed to be checked by human users, the formal verification concerned is done. Thus, proof scores are subject to human errors, which cannot be checked by CafeOBJ as just mentioned. To address the issue, Riesco and Ogata \cite{RiescoO18tosem} have developed CafeInMaude Proof Generator (CiMPG) and Proof Assistant (CiMPA), where CafeInMaude is the world's second implementation of CafeOBJ in Maude, which is a sibling language of CafeOBJ. CiMPG takes proof scores and generate proof scripts that can be checked by CiMPA, a proof assistant for CafeOBJ. If the proof script generated by CiMPG from proof scores are successfully checked by CiMPA, we can conclude that proof scores are correct and do not have any human errors. CafeOBJ has been used to formally specify and verify several security protocols \cite{10.5555/1765533.1765569, 10.5555/646542.696196, 1357944, 1437139}. However, not all proof scores as they are can be handled by CiMPG. While conducting formal verification with CiMPG can guarantee the reliability even though it is quite strict to tackle. This is because some specific types of case splitting, such as case splitting based on constructors, are permitted in proof scores that can be handled by CiMPG. Some different types, such as case splitting based on semantics, are used in those existing proof scores. To utilize the existing proof scores for CiMPG and CiMPA, we need to learn what and how we should do for the existing proof scores. Furthermore, because those existing proof scores are large, it may take an unreasonable amount of time to handle such large proof scores with CiMPG, we need to come up with how to tackle the issue. We would like to check if the proof scores are correct with CiMPG and CiMPA as well. To this end, we take the proof scores developed for TLS 1.0 handshake protocol \cite{1437139}. This is why we use TLS 1.0 but neither TLS 1.2 nor 1.3 in the present paper. TLS 1.0 handshake protocol is referred to as TLS in the rest of the paper.

CiMPG and CiMPA have been used to formally verify laboratory authentication protocols, such as NSLPK (Needham-Schroeder-Lowe Public Key) for the nonce secrecy property \cite{RiescoO18tosem}, IFF (Identity-Friend-or-Foe) for the identifiable property \cite{twmon} and NSLPK for the correspondence property as well as the nonce secrecy property \cite{twmon}. We are the first who have formally verify TLS with CiMPG and CiMPA.

A network in the formal specification of TLS is formalized as a soup of messages, where a soup is an associative-commutative collection. Let \verb|_,_| be the constructor of non-empty soups. Let us consider a case splitting as follows: a case is split into two sub-cases: (1) there is a specific message $m$ in the network and (2) there is no such a message in the network. (1) can be characterized by the equation \verb!eq nw(s) = m , nw .!, while (2) can be expressed by the equation \verb!eq m \in nw(s) = false.! \verb!nw(s)! denotes the network (the soup of messages) in a given state $s$ and \verb!nw! denotes an arbitrary network. The first equation says that \verb!nw(s)! equals \verb!m , nw!, and then there exists \verb!m in nw(s)!. \verb|_\in_| is the membership predicate for soups and the second equation says that there does not exist in \verb!nw(s)!. Hence, the case splitting is semantically correct. However, the case splitting cannot be handled by CiMPG. The first equation should be revised as follows: 
\verb!eq m \in nw(s) = true!. CiMPG found one missing lemma, meaning that the existing proof scores for TLS had a human error. It took too much time to handle all proof scores at the same with CiMPG. Thus, we need to tackle each proof score one by one. To this end, we are supposed to provide all needed lemmas for the proof scores. Because all lemmas except for one are given, we know what lemmas are needed for each proof score in advance. There is one proof score such that even if we handle the proof score only with CiMPG, it took an unreasonable amount of time to do so. Therefore, we handle each induction case one by one for the proof score, reducing the time taken to the proof script with CiMPG. Note that the main proof technique used is (simultaneous) structural induction on reachable states. We describe how to revise the existing proof scores, how to find the missing lemma, the lemma, how to handle each proof score one by one, and how to handle each induction case one by one as tips on handling existing large proof scores.

% You should summarize the main contributions here in Introduction. But I do not clearly know the main contributions now and then cannot give you very concrete candidates.

The rest of the paper is organized as follows. Section \ref{pre} gives some preliminaries by using a small example. Section \ref{tls} describes TLS 1.0 protocol, TLS handshake protocol and the abstract handshake protocol. Section \ref{fstls} presents the formal specification of TLS handshake protocol. Section \ref{fvtls} describes a way to use CiMPG and CiMPA for existing large proof scores in formal verification with subsections in which how to revise the existing proof scores, how to find one missing lemma, how to come up with an idea to handle each proof score one by one, and how to handle each induction case one by one with CiMPG are discussed respectively. Some related work is mentioned in Section \ref{relatedwork}. Finally, Section \ref{conclusion} contains our
conclusions and outlines some lines of future work. The formal specification of TLS, the revised proof scores and the proof scripts generated by CiMPG are available at \url{ https://github.com/twmon14/fvtlscimpg}.

% As written, the formal verification is too weak as the main contributions. You need to have at least one section that is dedicated to the main contributions.

\section{Preliminaries}\label{pre}
% Please make one section that is dedicated to Preliminaries where you are supposed to describe CafeOBJ (or CafeInMaude), proof socres, CiMPG, proof script and CiMPA by using a small example, such as IFF.
We present in this section some preliminaries such as
CafeOBJ specification of the IFF protocol, how to prove properties on this protocol by using proof scores. Then we show CafeInMaude, how to use CiMPA for proving the properties of the example and how CiMPG infers the proof script.

\subsection{CafeOBJ and IFF in CafeOBJ} \label{cafeobj}
CafeOBJ \cite{DiaconescuF98amast} is a direct successor of OBJ3, the best-known algebraic specification language, and its system is also referred to as CafeOBJ. Proof scores are proof plans written in an algebraic specification language, such as OBJ3 and CafeOBJ.

CafeOBJ is a formal specification language for writing formal specifications for a wide variety of software and hardware systems and for verifying their properties. CafeOBJ implements equational logic by rewriting and can be used as a powerful platform for proving properties of systems. CafeOBJ provides several features to ease the specification of systems. These features include a flexible mix-fix syntax, a powerful and clear typing system with ordered sorts, parameterized modules and views for instantiating the parameters, module expressions, operators for defining terms, equations for defining the (possibly conditional) equalities
between terms, and (possibly conditional) transitions for specifying how a system evolves, among others. Regarding verification, specifiers can also write proof scores (Futatsugi et al. 2012) in CafeOBJ and perform proofs by executing these proof scores. Proof scores consist of the reduction, by
means of equations, of goal-oriented terms in user-defined modules (the so-called open–close environments, which allow extension of previous theories by adding new operators and equations) and checking whether they are reduced to the expected value (usually true). More specifically, given a property that must hold in an initial module, we have that:
—These goal-oriented terms must take into account whether (i) we require induction and
hence a ground term built with constructors should substitute some of the variables from
the goal while the rest should be substituted by fresh constants; or (ii) we need to use any
of the hypotheses, probably by using an implication.
—These user-defined modules must include the definitions for all fresh constants required
by the equations and the equations standing for the hypotheses or case splittings, among
others.

\subsection{Proof Scores for Verifying IFF} \label{pscores}

\subsection{Verifying QLOCK with CiMPA} \label{cimpa}

\subsection{Verifying QLOCK with CiMPG} \label{cimpg}

\section{TLS}\label{tls}
TLS \cite{dierk} provides privacy and data integrity between client/server communications. The protocol consists of four sub-protocols. They are TLS handshake protocol, the change cipher spec protocol, the alert protocol and TLS record protocol. We focus on the TLS handshake protocol in this paper. When client and server want to establish a secure communication, TLS handshake protocol is used to negotiate a cipher suite and security parameters between client and server. 

% The change cipher spec protocol is used when each of two peers(client/server) want to notify the other that subsequent messages after handshake process will be protected under the newly negotiated cipher suite, and security parameters. If either of them notices something wrong, one lets the other know about it with the alert protocol. TLS record protocol provides private and reliable communications between the two peers using the negotiated cipher suite and security parameters.

If a cipher suite used in the message is weaker than the available one to both peers or the security parameters shared by both peers are leaked by some reasons, then an adequate level of security cannot be obtained. Therefore, the security of TLS largely depends on a cipher suite and security parameters negotiated by client/ server in handshake process. Thus, it can be said that among four sub-protocols, TLS handshake protocol takes part in the most important role and the security of TLS relies on TLS handshake protocol. 

\begin{table}[]
\centering
    \begin{tabular}{ c c c }
    Client &  & Server \\ 
    \hline
    & $\leftarrow$ & HelloRequest$^*$ \\  
    ClientHello & $\rightarrow$ & \\ 
    & $\leftarrow$ & ServerHello \\  
    & $\leftarrow$ & Certificate$^*$ \\  
    & $\leftarrow$ & ServerKeyExchange$^*$ \\  
    & $\leftarrow$ & CertificateRequest$^*$ \\  
    & $\leftarrow$ & ServerHelloDone$^*$ \\  
    Certificate$^*$ & $\rightarrow$ & \\ 
    ClientKeyExchange & $\rightarrow$ & \\ 
    CertificateVerify$^*$ & $\rightarrow$ & \\ 
    \verb![ChangeCipherSpec]! & $\rightarrow$ & \\ 
    Finished & $\rightarrow$ & \\ 
    & $\leftarrow$ & \verb![ChangeCipherSpec]! \\  
    & $\leftarrow$ & Finished \\ 
    Application Data & $\leftrightarrow$ & Application Data \\ 
    \end{tabular}
    \caption{TLS handshake protocol}
    \label{tab:tb1}
\end{table}

\subsection{TLS handshake protocol}\label{handshake}
Table \ref{tab:tb1} shows the message exchanges between client and server in TLS handshake protocol, which is formally verified in the present paper. To initiate a new run of the protocol, a server sends a HelloRequest message to a client or a client sends a ClientHello message to the server. On receipt of the HelloRequest message from server, the client replies to server with a ClientHello message. A ClientHello message contains the basic information, such as a version number of TLS, a list of cipher suites that are available to the client, a random number generated by client.

On the receipt of the ClientHello message, the server replies to the client with a ServerHello message, which consists of a version number of TLS that is lower than or equal to the one suggested by the client and the highest supported by the server, a session ID, a cipher suite chosen from the list suggested by the client in the ClientHello message, a random number generated by server, etc. 

If the server should be authenticated, the server sends  his/her certificate to the client. If the server Certificate message does not contain enough data to allow the client to exchange a pre-master secret, the server sends a ServerKeyExchange message to the client. The server can optionally request a certificate from the client by sending a CertificateRequest message. The server sends a ServerHelloDone message to the client to indicate the end of the ServerHello.

When the client receives ServerHelloDone message, the client checks the messages received. When it is necessary, the client sends his/her certificate to the server. The ClientKeyExchange message is sent by the client after he/she receives a ServerHelloDone message. The ClientKeyExchange message contains a pre-master secret which is a random number generated by the client. Two key exchange methods (RSA and Diffie-Hellman) are specified to exchange a pre-master secret. 

The client can optionally send a CertificateVerify message to provide a verification of the client certificate.
The client notifies the server with the change cipher spec protocol that subsequent messages will be protected under the newly negotiated cipher suite and security parameters and sends a Finished message to the server. The Finished message is protected under the just negotiated cipher suite and security parameters.

On receipt of the client Finished message from the client, the server
checks the message. If the message is correct, the server notifies the client with the change cipher spec protocol that subsequent messages will be protected under the newly negotiated cipher suite and security parameters. The server then sends a server Finished message to the client to verify that the handshake process is successful.

The client checks the message when the server Finished message is received. If the message is correct, the handshake process is done successfully between client and server and the client can exchange application data securely with server in the current session.

A previously established session and a current session
can be resumed and/or duplicated without exchanging all handshake messages. If a client wants to resume or duplicate a session, he/she sets a session ID in a new ClientHello message and sends it to a server. When the ClientHello message is received, if the server wants to resume or duplicate the session, he/she replies to the client with a new ServerHello message. The ClientHello and ServerHello messages are protected under the current cipher suite and security parameters. 

The server then notifies the client to use the newly negotiated security parameters for the session with the same cipher suite. A server Finished message is then sent to the client. On receipt of the server Finished message, the client checks the message received. If the message is correct, the client notifies the server to use the newly negotiated security parameters for the session and a client Finished message is then sent to the server. The server checks the message on the receipt of the client Finished message. If the message is correct, the session is then resumed and/or duplicated. The client can exchange application data securely with server in that session.

\begin{table}[]
\centering
 \caption{An abstract handshake protocol}
    \begin{tabular}{ c c c }
    ClientHello & $A \rightarrow B$  & Rand$_A$, ListOfChoices \\ 
    ServerHello & $B \rightarrow A$ & Rand$_B$, SID, Choice \\  
    Certificate & $B \rightarrow A$ & Cert$_B$ \\ 
    KeyExchange & $A \rightarrow B$ & $\varepsilon_{K_B}$(PMS) \\ 
    ClientFinished & $A \rightarrow B$ & $\varepsilon_{ClientKey}$(ClientFinish) \\
   ServerFinished & $B \rightarrow A$ & $\varepsilon_{ServerKey}$(ServerFinish) \\
   \\
   ClientHello2 & $A \rightarrow B$  & Rand$_A$, SID \\
   ServerHello2 & $B \rightarrow A$ & Rand$_B$, SID, Choice \\
   ServerFinished2 & $B \rightarrow A$ & $\varepsilon_{ServerKey}$(ServerFinish2) \\
   ClientFinished2 & $A \rightarrow B$ & $\varepsilon_{ClientKey}$(ClientFinish2) \\
    \end{tabular}
    % \setlength{\parindent}{4em}
   
    \label{tab:tb2}
\end{table}

\subsection{The Abstract Handshake Protocol}\label{abstracthandshake}
Table \ref{tab:tb2} shows the abstract version of TLS handshake protocol. In the protocol, \textbf{A} denotes a client and \textbf{B} a server respectively. In the table, the first six exchanged messages are the full handshake process between the client and the server. The remaining ones are for the resumption of a previously established session or the duplication of a current session.

% Cryptographic functions used in the protocol are H(.)
% (a one-way hash function), $\varepsilon_K(.)$ (an encryption function with symmetric or asymmetric key K) and S$_X(.)$ (a digital signature function with principal X’s private key). The other primitives used in the protocol are Rand$_X$ (a random number generated by principal X), ListOfChoices (a list of cipher suites), Choice (a cipher suite), SID (a session ID), PMS (a pre-master secret), CA (certificate authority) and K$_X$ (principal X's public key).

% Composite data occurring in the protocol are as follows:
% Cert$_X$ : X, K$_X$, S$_{CA}$(X, K$_X$) \newline
% ClientKey : H(A, PMS, Rand$_A$, Rand$_B$) \newline
% ClientKey : H(B, PMS, Rand$_A$, Rand$_B$) \newline
% ClientFinish : H("client", A, B, SID, ListOfChoices, Choice, Rand$_A$, Rand$_B$, PMS)\newline
% ServerFinish : H("server", A, B, SID, ListOfChoices, Choice, Rand$_A$, Rand$_B$, PMS)\newline
% ClientFinish2 : H("client", A, B, SID, Choice, Rand$_A$, Rand$_B$, PMS)\newline
% ServerFinish2 : H("server", A, B, SID, Choice, Rand$_A$, Rand$_B$, PMS)\newline

There are some assumptions in the abstract handshake protocol as follows:
\begin{itemize}
\item A server always sends his/her certificate to a client in handshake process; 
\item A server sends neither SeverKeyExchange nor CertificateRequest messages; 
\item A client sends neither Certificate nor CertificateVerify messages; \item The ChangeCipherSpec messages are implicit and not considered in the abstract handshake protocol; 
\item There exists only one trusted certificate authority denoted by CA; 
\item Only RSA method is used for exchanging pre-master secrets; 
\item The content of Finished messages is not the hash of the security parameters and handshake messages exchanged, but that of
two random numbers, a pre-master secret, etc.
\end{itemize}
% 		\end{verbatim}
% 	\end{small}

\section{Formal Specification of TLS handshake protocol} \label{fstls}
The formal specification of the protocol written in CafeOBJ is available and the modeling of the system has already been described in \cite{1437139}. We slightly revise the existing specification and the description of the formal specification of the protocol is given in this section. There are two kinds of principals such as trustable and untrustable ones. Trustable principals exactly follow the protocol, while untrustable ones do something against the protocol. 

% Suppose that there exists not only multiple trustable
% principals but also multiple malicious (untrustable) principals, and the cryptosystem used is perfect. Trustable
% principals exactly follow the protocol, while malicious ones may do something against the protocol as well. The combination and cooperation of malicious principals is modeled as the most general intruder Dolev-Yao \cite{dolev}. 
% An intruder can glean as much information as possible from messages flowing in the network and create fake messages based on the gleaned information, provided that the intruder cannot break the perfect cryptosystem.

% We specify 10 operators (data construtors) to define 10 kinds of messages. The data constructors used in TLS are declared as follows:
The 10 kinds of messages defined with 10 operators (data constructors) are declared as follows.
\begin{small}
		\begin{verbatim}
op ch  : Prin    Prin   Prin  Rand ListOfChoices -> Msg
op sh  : Prin    Prin   Prin  Rand Sid Choice    -> Msg
op ct  : Prin    Prin   Prin  Cert               -> Msg
op kx  : Prin    Prin   Prin  EncPms             -> Msg
op cf  : Prin    Prin   Prin  EncCFin            -> Msg
op sf  : Prin    Prin   Prin  EncSFin            -> Msg
op ch2 : Prin    Prin   Prin  Rand Sid           -> Msg
op sh2 : Prin    Prin   Prin  Rand Sid Choice    -> Msg
op cf2 : Prin    Prin   Prin  EncCFin2           -> Msg
op sf2 : Prin    Prin   Prin  EncSFin2           -> Msg
		\end{verbatim}
	\end{small}
where \verb!Msg! is the sort denoting messages. For data constructor \verb!x! (where \verb!x = ch!, \verb!sh!, \verb!ct!, \verb!kx!, \verb!cf!, \verb!sf!, \verb!ch2,! \verb!sh2!, \verb!sf2!, \verb!cf2!), predicate \verb!x!? is defined to check if a given message is \verb!x! message.

The other sorts and the corresponding data
constructors that constitute the messages are declared as follows:
\begin{itemize}
  \item \verb!Principal! denotes principals. There are two special principals; one is the \verb!intruder! denoted by intruder and the other the certificate authority denoted by \verb!ca!. We suppose that \verb!intruder! does not equal \verb!ca!. 
  \item \verb!Rand! denotes random numbers generated by principals.
\item \verb!ListOfChoices! denotes lists of cipher suites. Operator \verb|_\in_| is the membership predicate of lists.
  \item \verb!Choice! denotes cipher suites. 
  \item \verb!Sid! denotes session IDs. 
  \item \verb!PubKey! denotes public keys. The principal $a$’s public key is denoted by \verb!k!($a$).
\item \verb!Sig! denotes digital signatures of pairs of a principal and a public key. The digital signature of the pair of principal $b$ and public key $k$ signed by $ca$ is denoted by \verb!sig!($ca$, $b$, $k$).
\item \verb!Cert! denotes certificates of public keys. Given principal $a$, public key $k$ and signature $g$, the certificate that $k$ is $a$’s,
which is certified by $g$, is denoted by \verb!cert!($a$, $k$, $g$).
\item \verb!Secret! denotes secret values that make pre-master secret globally unique and unguessable. 
\item \verb!Pms! denotes premaster secrets. Given two principals $a,b$ and a secret value $s$, a pre-master secret generated by client $a$ for server $b$ is denoted by \verb!pms!($a$, $b$, $s$).
\item \verb!Key! denotes hashes used as symmetric keys to encrypt Finished messages. Given principal $a$, pre-master secret $pms$ and two random numbers $r1,r2$, the hash of those quantities is denoted by \verb!k!($a$, $pms$, $r1, r2$).
\item \verb!CFinish! denotes ClientFinish’s. Given two principals $a, b$, session ID $i$, list $l$ of cipher suites, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ClientFinish is denoted by \verb!cfin!($a, b$, $i$, $l$, $c$, $r1, r2$, $s$).
\item \verb!SFinish! denotes ServerFinish’s. Given two principals $a, b$, session ID $i$, list $l$ of cipher suites, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ServerFinish is denoted by \verb!sfin!($a, b$, $i$, $l$, $c$, $r1, r2$, $s$).
\item \verb!CFinish2! denotes ClientFinish2’s. Given two principals $a, b$, session ID $i$, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ClientFinish is denoted by \verb!cfin2!($a, b$, $i$, $c$, $r1, r2$, $s$).
\item \verb!SFinish2! denotes ServerFinish2’s. Given two principals $a, b$, session ID $i$, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ServerFinish is denoted by \verb!sfin2!($a, b$, $i$, $c$, $r1, r2$, $s$).
\item \verb!EncPms! denotes pre-master secrets encrypted by public keys. Pre-master secret $pms$ encrypted by public key $k$ is denoted by \verb!epms!($k$, $pms$).
\item \verb!EncCFin! denotes ClientFinish’s encrypted by symmetric keys. ClientFinish $f$ encrypted by symmetric key $k$ denoted by \verb!ecfin!($k$, $f$).
\item \verb!EncSFin! denotes ServerFinish’s encrypted by symmetric keys. ServerFinish $f$ encrypted by symmetric key $k$ denoted by \verb!esfin!($k$, $f$).
\item \verb!EncCFin2! denotes ClientFinish2’s encrypted by symmetric keys. ClientFinish2 $f$ encrypted by symmetric key $k$ denoted by \verb!ecfin2!($k$, $f$).
\item \verb!EncSFin2! denotes ServerFinish2’s encrypted by symmetric keys. ServerFinish2 $f$ encrypted by symmetric key $k$ denoted by \verb!esfin2!($k$, $f$).
\item \verb!Session! denotes a quadruple of a cipher suite, two random numbers and a pre-master secret. A quadruple of cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $pms$ is denoted by \verb!st!($c$, $r1, r2$, $pms$).
\end{itemize}

The projection operators are defined to return the arguments of the data constructors. The projection operators such as \verb!crt!, \verb!src! and \verb!dst! return the first, second and third arguments of a message, respectively. The first, second and  third  arguments  of  each  message are  the  actual creator,  the  seeming  sender  and  the  receiver  of the  corresponding message. The other projection operators 
% such as \verb!client(pms!($a$, $b$, $s$)) = $a$, \verb!server(pms!($a$, $b$, $s$)) = $b$ and \verb!secret(pms!($a$, $b$, $s$)) = $s$ 
are also defined likewise.

% For each data constructor such as \verb!pms!, \verb!sig!, etc., projection operators such as \verb!client!, \verb!server! and \verb!secret! that return arguments of the data constructor are also defined. For example, \verb!client(pms!($a$, $b$, $s$)) = $a$, \verb!server(pms!($a$, $b$, $s$)) = $b$ and \verb!secret(pms!($a$, $b$, $s$)) = $s$. Other projection operators for other data constructor are also defined likewise.

%  Given a term denoting a message,  The first, second and  third  arguments  of  each  message are  the  actual creator,  the  seeming  sender  and  the  receiver  of the  corresponding message. The first argument is meta-information that is only available to the outside observer and that cannot be forged by the intruder; while the remaining arguments may be forged by the intruder. 

% Suppose that there exists a message in the network. It is true that the principal denoted by the first
% argument has sent the message. If the first argument is the
% intruder and the second one is not, then the message has been
% faked by the intruder. For example, a principal $a$ receives a message denoted by \verb!ct!($b$', $b$, $a$, $cert$). 
% Since messages are supposed to be never deleted from the network, if there exists a message denoted by
% \verb!ct!($b$, $b$, $a$, $cert$) the network, we can conclude that the message received by $a$ really originates from $b$.
% Therefore, this formalization of messages makes it possible to describe a property such as one that a message received by a principal really originates from the seeming sender (second argument) of the message. 

% The  network  is  modeled  as  a  multiset  of  messages,  in which the intruder can use as his/her storage. Any message that has been sent or put once into the network is supposed to be never deleted from the network because the intruder can replay the message repeatedly, although the intruder cannot forge the first argument. Consequently, the empty network (i.e., the empty multiset) means that no messages have been sent.

The  network  is  modeled  as  a  bag (multiset)  of  messages,  in which each principal’s storage. Any message that has been sent into the network is supposed to be never deleted from the network because the intruder can replay the message repeatedly, although the intruder cannot forge the first argument. The empty network means that no messages have been sent.

% The intruder tries to glean seven kinds of quantities from
% the network as much as possible. The seven kinds of quantities are pre-master secrets, digital signatures and five kinds of ciphertexts.

The collections of the seven quantities gleaned by the intruder from the network are denoted by the following operators, respectively:
\begin{small}
\begin{verbatim}
op cpms : Network -> ColPms
op csig : Network -> ColSig
op cepms : Network -> ColEncPms
op cecfin : Network -> ColEncCFin
op cesfin : Network -> ColEncSFin
op cecfin2 : Network -> ColEncCFin2
op cesfin2 : Network -> ColEncSFin2
\end{verbatim}
\end{small}	
where Network is the sort denoting networks. Col$X$ is
the sort denoting collections of quantities denoted
by sort $X$.

% The operators are defined with equations. For example, the operator \verb!cpms! is defined with equations as follows:
% \begin{small}
% \begin{verbatim}
% eq PMS \in cpms(void) = (client(PMS) = intruder) .
% ceq PMS \in cpms(M,NW) = true if (kx?(M) and
% owner(k(epms(M))) = intruder and PMS = pms(epms(M))) .
% ceq PMS \in cpms(M,NW) = PMS \in cpms(NW) if not(kx?(M) and
% owner(k(epms(M))) = intruder and PMS = pms(epms(M))) .
% \end{verbatim}
% \end{small}	
% where constant \verb!void! denotes the empty bag. Operator    \verb|_,_| of \verb!M,NW! is the data constructor of bags. The first equation says that any pre-master secret generated by the intruder is always available to the intruder and no other pre-master secrets are at any initial state. Messages from which pre-master secrets can be gleaned are Certificate messages only. The second equation says that if there exits a Certificate message in the network and the ciphertext in the message is encrypted with the intruder’s public key, then the pre-master secret in the message can be available to the intruder. The third one says that no pre-master secrets cannot be gleaned from any non-Certificate messages and any Certificate messages whose ciphertexts are not encrypted with the intruder’s public key. The remaining operators are also defined likewise.

The operators are defined with equations. For example, the operator \verb!cepms! is defined with equations as follows:
\begin{small}
\begin{verbatim}
eq EPMS \in cepms(void) = false .
ceq EPMS \in cepms(M,NW) = true if (kx?(M) and 
not(owner(k(epms(M))) = intruder) and EPMS = epms(M)) .
ceq EPMS \in cepms(M,NW) = EPMS \in cepms(NW) if not(kx?(M) and
not(owner(k(epms(M))) = intruder) and EPMS = epms(M)) .
\end{verbatim}
\end{small}	
where constant \verb!void! denotes the empty bag. Operator    \verb|_,_| of \verb!M,NW! is the data constructor of bags. Messages from which encrypted pre-master secrets can be gleaned are KeyExchange messages only. The equations say that if there exits a KeyExchange message in the network and the pre-master secret in the message is not
encrypted with the intruder’s public key, then the intruder can glean the encrypted pre-master secret in the message.
% The second equation says that if there exits a KeyExchange message in the network and the pre-master secret in the message is not encrypted with the intruder’s public key, then the encrypted pre-master secret in the message can be available to the intruder. The third one says that no encrypted pre-master secrets cannot be gleaned from any non-KeyExchange messages and any KeyExchange messages whose pre-master secrets are encrypted with the intruder’s public key. 
The remaining operators are also defined likewise.

Five observational functions have been declared as follows:
\begin{small}
\begin{verbatim}
op nw : Protocol -> Network
op ss : Protocol Prin Prin Sid -> Session
op ur : Protocol -> URand
op ui : Protocol -> USid
op us : Protocol -> USecret
\end{verbatim}
\end{small}	
where \verb!Protocol! is  the  sort  denoting  the  state  space. \verb!URand!, \verb!USid! and \verb!USecret! are the  sorts denoting sets of random numbers, ones of session IDs and ones of secrets. 
Let $p$ denotes a state of the protocol. \verb!nw!($p$) denotes the network, \verb!ur!($p$) the set of used random numbers, \verb!ui!($p$) that of used session IDs and \verb!us!($p$) that of used secrets in the state. 
\verb!ss!($p$, $a$, $b$, $i$) denotes the principal $a$’s session state identified by session ID $i$ with principal $b$ in the state where $a, b$ denotes principals and $i$ a session ID.

The behaviors of the principals are modeled by transitions. The behavior of trustable principals is defined by 12 kinds of transitions corresponding to sending 10 kinds of messages and receiving two Finished messages respectively.
% We define 27 transitions together with one constant of \verb!Protocol! to represent an arbitrary initial state.
% The behavior of trustable principals is modeled by 12
% kinds of transitions. 10 of them correspond to sending
% the 10 kinds of messages. The remaining two correspond
% to clients’ receiving ServerFinished messages and
% servers’ receiving ClientFinished2 messages, respectively.
The 12 kinds of transitions are denoted by the following operators:
\begin{small}
\begin{verbatim}
op chello : Protocol Prin Prin Rand ListOfChoices ->
Protocol {constr}
op shello : Protocol Prin Rand Sid Choice Msg -> Protocol {constr}
op cert : Protocol Prin Msg Msg -> Protocol {constr}
op kexch : Protocol Prin Secret Msg Msg Msg -> Protocol {constr}
op cfin : Protocol Prin Secret Msg Msg Msg Msg -> Protocol {constr}
op sfin : Protocol Prin Msg Msg Msg Msg Msg -> Protocol {constr}
op compl : Protocol Prin Secret Msg Msg Msg Msg Msg Msg ->
Protocol {constr}
op chello2 : Protocol Prin Prin Secret Rand Sid -> 
Protocol {constr}
op shello2 : Protocol Prin Rand Msg -> Protocol {constr}
op cfin2 : Protocol Prin Secret Msg Msg -> Protocol {constr}
op sfin2 : Protocol Prin Msg Msg Msg -> Protocol {constr}
op compl2 : Protocol Prin Secret Msg Msg Msg Msg -> 
Protocol {constr} 
\end{verbatim}
\end{small}	
Each transition is defined with equations.
% The 12 action operators are defined with equations. 
In this paper, we show the equations for \verb!chello!, which are declared as follows:
\begin{small}
\begin{verbatim}
op c-chello : Protocol Prin Prin Rand ListOfChoices -> Bool
eq c-chello(P,A,B,R,L) = not(R \in ur(P)) .
ceq nw(chello(P,A,B,R,L)) = ch(A,A,B,R,L) , nw(P) 
if c-chello(P,A,B,R,L) .
eq  ss(chello(P,A,B,R,L),A2,B2,I2) = ss(P,A2,B2,I2) .
ceq ur(chello(P,A,B,R,L)) = R ur(P) if c-chello(P,A,B,R,L) .
eq  ui(chello(P,A,B,R,L)) = ui(P) .
eq  us(chello(P,A,B,R,L)) = us(P) .
ceq chello(P,A,B,R,L)     = P if not c-chello(P,A,B,R,L) . 
\end{verbatim}
\end{small}	
where A, A2, B, and B2 are CafeOBJ variables of the sort Prin, and P, R, L, and I are CafeOBJ variables of the sorts Protocol, Rand, ListOfChoices, and Sid, respectively.
The  equations  say  that  if c-chello(P, A, B, R, L) is  true
(i.e., random number R has   not   been   used), then the ClientHello message ch(A, A, B, R, L) is put into the network nw(P), R is put into ur(P); if c-chello(P, A, B, R, L) is  false,  nothing  changes.  The remaining transitions can be defined likewise.

The behavior of the intruder is modeled by 15
kinds of transitions. The intruder fakes messages based on the gleaned information. 
% The effective condition to the action operators is that the necessary information is available to the intruder. 
The 15 kinds of transitions are defined by the following operators:
\begin{small}
\begin{verbatim}
op fakeChello : Protocol Prin Prin Rand ListOfChoices ->
Protocol {constr}
op fakeShello : Protocol Prin Prin Rand Sid Choice ->
Protocol {constr}
op fakeCert : Protocol Prin Prin PubKey Sig -> Protocol {constr}
op fakeKexch1 : Protocol Prin Prin EncPms -> Protocol {constr}
op fakeKexch2 : Protocol Prin Prin PubKey Pms -> Protocol {constr}
op fakeCfin1 : Protocol Prin Prin EncCFin -> Protocol {constr}
op fakeCfin2 : Protocol Prin Prin Sid ListOfChoices Choice Rand 
Rand Pms -> Protocol {constr}
op fakeSfin1 : Protocol Prin Prin EncSFin -> Protocol {constr}
op fakeSfin2 : Protocol Prin Prin Sid ListOfChoices Choice Rand 
Rand Pms -> Protocol {constr}
op fakeChello2 : Protocol Prin Prin Rand Sid -> Protocol {constr}
op fakeShello2 : Protocol Prin Prin Rand Sid Choice ->
Protocol {constr}
op fakeCfin21  : Protocol Prin Prin EncCFin2 -> Protocol {constr}
op fakeCfin22  : Protocol Prin Prin Sid Choice Rand Rand Pms -> 
Protocol {constr}
op fakeSfin21  : Protocol Prin Prin EncSFin2 -> Protocol {constr}
op fakeSfin22  : Protocol Prin Prin Sid Choice Rand Rand Pms -> 
Protocol {constr} 
\end{verbatim}
\end{small}	
% Each operator is defined with equations. 

In the existing specification of the protocol, the state space is denoted by hidden sort and the transition and observation operators with respect to hidden sorts are declared by starting with \verb !bop!. 
We slightly revise the original specification of the state space denoting visible sort and the transition and observation operators are declared with respect to visible sorts by starting with \verb !op! as behavioral specifications are not supported in CafeInMaude.

To successfully complete the formal verification of TLS protocol, we add one useful lemma in the original specification. The trivial lemma is defined by the following operator and equation as follows:
\begin{small}
\begin{verbatim}
  op lm1 : Msg Msg Network -> Bool
  eq lm1(M, M2, NW) = (M = M2 and M \in NW) implies (M2 \in NW) .
\end{verbatim}
\end{small}	
The equation says that there exists a message \verb!M! in the network and if \verb!M2! message is equivalent to \verb!M!, then \verb!M2! is also in the network. We use the trivial lemma in some invariants (\verb!inv7, 8, 12, 13, 14, 16, 17, 18!) and the formal verification is successfully done with the help of this lemma.

\section{A Way to Use CiMPG and CiMPA for Existing Large Proof Scores}\label{fvtls}
% You should make sub-sections such that each sub-section is dedicated to one contribution that is a tip of use of CiMPG and CiMPA.
The five properties of the protocol \cite{1437139} are formalized as CafeOBJ terms. These five properties are (1) the secrecy property of pre-master secrets, (2) the correspondence (or authentication) one from a client point of view, (3) the correspondence one from a server point of view, (4) the correspondence one for resumed sessions from a client point of view, and (5) the correspondence one for resumed sessions from a server point of view. 13 lemmas are used by Ogata and Futatsugi to formally verify these five properties. Moreover, we found one missing lemma and it is required to use in the formal verification of the protocol with CiMPG. In this paper, the word property is used interchangeably with invariant. Let us refer to the properties as inv\textbf{$x$} where x = 1 to 18. inv1, inv3, inv5, inv17 and inv18 are the five properties of the protocol. The first property is formalized as follows: 
\begin{small}
\begin{verbatim}
eq inv1(P,PMS) = (PMS \in cpms(nw(P)) implies 
(client(PMS) = intruder or server(PMS) = intruder)) .
\end{verbatim}
\end{small}
The equation says that if a pre-master secret is available to the intruder as a server, the pre-master secret has been generated by the intruder or a client has generated it for a session with the intruder. This means that the intruder cannot obtain any pre-master secrets for sessions in which the intruder is not involved. 

TO EXPLAIN INV3, INV5, INV17, INV18

The five properties inv12, inv13, inv16, inv17 and inv18 have been proved by case analysis with other properties as lemmas, and the remaining ones by (simultaneous) structural induction on reachable states in \cite{1437139}. CiMPG cannot deal with proofs by case analysis. Thus, it is necessary to prove the five properties by structural induction on reachable states. We have written proof scores to do so while referring to some tips on writing proof scores \cite{Ogata2006}.

% Our purpose is to formally verify the properties of the protocol with the use of CiMPG and CiMPA.
% However, we need to make some modifications to the existing proof scores with CiMPG [cite{twmon} so that the proof scores can be run successfully in CafeInMaude environment and CiMPG can generate the correct proof scripts from proof scores for CiMPA. While we revise the existing proof scores, there are many cases in which we need to conduct the case splittings by introducing equations and/or use other properties as lemma to strengthen the inductive hypothesis many times. Moreover, we revise/write the proof scores for five properties (inv12, inv13, inv16, inv17 and inv18) by induction on the number of transitions applying some tips on writing proof scores in the CafeOBJ method \cite{Ogata2006}.

% The revised proof scores are feed into CafeInMaude and if all proof scores are reduced to \verb!true! then the corresponding properties are proved. If they are not directly reduced to \verb!true!, case splitting or using lemma is required. Even if CafeInMaude returns \verb!true! for each open-close fragment of a proof score, CiMPG may not successfully generate proof scripts from the proof score. In such case, we need to revise the proof score again. If all proof scores are complete, we are ready to use CiMPG to formally verify the properties. In order to use CiMPG, we slightly need to annotate the proof scores. Let us use one example of proof score open-close fragment that is annotated to use CiMPG. The following proof fragment is a proof fragment of one case from inv13
It is necessary to annotate each open-close fragment of proof
scores so that proof scores can be handled by CiMPG. Let us take
one open-close fragment annotated from the proof score of inv13:
\begin{small}
\begin{verbatim}
open INV .
  :id(tls)
  op p : -> Protocol .
  ops a b b1 : -> Prin .
  ops r1 r2 : -> Rand .
  op l : -> ListOfChoices .
  op c : -> Choice .
  op i : -> Sid .
  op s : -> Secret .
  op k : -> PubKey .
-- arbitrary objects
  ops p1 p2 : -> Prin .
  op esfin1 : -> EncSFin .
-- assumptions
  eq esfin1 \in cesfin(nw(p)) = true .
  eq esfin1 = esfin(k(b,pms(a,b,s),r1,r2),
  sfin(a,b,i,l,c,r1,r2,pms(a,b,s))) .
  eq a = intruder .
  eq a = p1 .
  eq b = intruder .
  eq b = p2 .
  eq b1 = intruder . 
  red inv13(p,a,b,b1,r1,r2,l,c,i,s,k) implies
  inv13(fakeSfin1(p,p2,p1,esfin1),a,b,b1,r1,r2,l,c,i,s,k) .
close
\end{verbatim}
\end{small}
% where all the constants except for intruder denote arbitrary
% values of the intended sorts. For example, a, b, b1, p1 and p2 denote arbitrary values of sort Prin. Moreover, we need to add one more open-close fragment to the proof scores, which is as follows:
where :id(tls) is the annotation. CiMPG treats all open-close fragments annotated by :id(tls) for formal verification of TLS. Each proof score needs to have one special open-close fragment:
\begin{small}
\begin{verbatim}
open INV
  :proof(tls)
close
\end{verbatim}
\end{small}
% where \verb!tls! is just an identifier, can be replaced by another preferred one. Feeding the annotated proof scores into CiMPG, CiMPG automatically generates the proof script for CiMPA. Feeding the generated proof script into CiMPA, if CiMPA discharges all goals, confirming that the proof scores are correct. 
Each proof score is stored in a file. The special open-close
fragment informs CiMPG that the open-close fragments in the file
all of which are supposed to be annotated by :proof(tls) are to
be handled by CiMPG.

TO REVISE THIS PART
% This part should be revised.

% 1. Similar sentences are repeated, which is redundant.

% 2. You should write what is pointed out by CiMPG as errors.

% 3. Even though CiMPG suggests how to correct them but you can guess how to fix the errors from the information given by CiMPG.

% CiMPG+F may be able to fix the errors automatically or suggest you how to fix the errors.

% 4. If CiMPG did not fix the errors, you should write how you fixed the errors based on the information given by CiMPG.

% I does not enough to shoe the revised open-close fragment.
Before feeding the generated proof scripts from CiMPG into CiMPA, we need to check whether the generated proof scripts contain the errors since there is a situation that CiMPG may not generate proof scripts correctly when the proof scores are not correct. CiMPG generates a formal proof script when the proof score are correct and complete. We describe some examples on how to revise the proof scores so as to generate the correct proof scripts from proof scores by CiMPG. As an example, by the time we run the above proof score fragment with CiMPG, the generated proof script contains the errors indicating that the proof score is not correct. We then need to carefully take a look at the proof score and revise it accordingly by the indicated errors. Note that CiMPG points out the errors in generated proof scripts, but it does not suggest how to fix them. We remove some unnecessary equations/case splitting in the above proof passage and feed the revised proof passage into CafeInMaude to check whether it returns true or not. The revised one for the above proof fragment is as follows:
\begin{small}
\begin{verbatim}
open INV .
  :id(tls)
  op p : -> Protocol .
  ops a b b1 : -> Prin .
  ops r1 r2 : -> Rand .
  op l : -> ListOfChoices .
  op c : -> Choice .
  op i : -> Sid .
  op s : -> Secret .
  op k : -> PubKey .
-- arbitrary objects
  ops p1 p2 : -> Prin .
  op esfin1 : -> EncSFin .
-- assumptions
  eq esfin1 \in cesfin(nw(p)) = true .
  eq esfin1 = esfin(k(b,pms(a,b,s),r1,r2),
  sfin(a,b,i,l,c,r1,r2,pms(a,b,s))) .
  eq a = intruder .
red inv13(p,a,b,b1,r1,r2,l,c,i,s,k) implies
inv13(fakeSfin1(p,p2,p1,esfin1),a,b,b1,r1,r2,l,c,i,s,k) .
close
\end{verbatim}
\end{small}
The revised annotated proof fragment is fed into CiMPG and CiMPG, unfortunately can not generate the correct proof script for this proof score
% , there is still an error in the scripts 
letting us know that the proof score is still not good enough for CiMPG to generate the correct proof script and pointing out that using the equation \verb!a = intruder! for case splitting is not correct. Then we revise the proof score by removing that equation and feed the proof score into CiMPG. This time CiMPG can handle this case and generates the correct proof script. The revised proof score is as follows:
\begin{small}
\begin{verbatim}
open INV .
  :id(tls)
  op p : -> Protocol .
  ops a b b1 : -> Prin .
  ops r1 r2 : -> Rand .
  op l : -> ListOfChoices .
  op c : -> Choice .
  op i : -> Sid .
  op s : -> Secret .
  op k : -> PubKey .
-- arbitrary objects
  ops p1 p2 : -> Prin .
  op esfin1 : -> EncSFin .
-- assumptions
  eq esfin1 \in cesfin(nw(p)) = true .
  eq esfin1 = esfin(k(b,pms(a,b,s),r1,r2),
  sfin(a,b,i,l,c,r1,r2,pms(a,b,s))) .
red inv13(p,a,b,b1,r1,r2,l,c,i,s,k) implies
inv13(fakeSfin1(p,p2,p1,esfin1),a,b,b1,r1,r2,l,c,i,s,k) .
close
\end{verbatim}
\end{small}
% CiMPG could generate the correct proof scripts for CiMPA this time.
% Although writing proof scores is flexible to conduct formal verification, the verification may contain some flaws because proof scores are subject to human errors.
Human users can overlook some cases during the revision of the proof scores because several case splittings are in general possible for each goal. From this example, we experience that we do not need to introduce the equations unnecessarily even though CafeInMaude returns true for this proof passage. 
Let us consider the following proof passage corresponding to case sfin2 of inv6:
\begin{small}
\begin{verbatim}
open INV .
  op p : -> Protocol .
  ops a b : -> Prin .
  ops r1 r2 : -> Rand .
  op c : -> Choice .
  op i : -> Sid .
  op s : -> Secret .
-- arbitrary objects
  op p2 : -> Prin .
  ops m1 m2 m3 : -> Msg .
-- assumptions
  eq m1 \in nw(p) = true .
  eq m2 \in nw(p) = true .
  eq m3 \in nw(p) = true .
  eq ch2?(m1) = true .
  eq sh2?(m2) = true .
  eq cf2?(m3) = true .
  eq crt(m2) = p2 .
  eq src(m2) = p2 .
  eq src(m1) = dst(m2) .
  eq dst(m1) = p2 .
  eq src(m3) = dst(m2) .
  eq dst(m3) = p2 .
  eq sid(m1) = sid(m2) .
  eq (ss(p,dst(m2),p2,sid(m2)) = none) = false .
  eq choice(ss(p,dst(m2),p2,sid(m2))) = choice(m2) .
  eq ecfin2(m3) = ecfin2(k(dst(m2),pms(ss(p,dst(m2),p2,
  sid(m2))),rand(m1),rand(m2)),cfin2(dst(m2),p2,sid(m2),
   choice(m2),rand(m1),rand(m2),pms(ss(p,dst(m2),p2,sid(m2))))) .
  eq r1 = rand(m1) .
  eq a = dst(m2) .
  eq i = sid(m2) .
  eq c = choice(m2) .
  eq b = p2 .
  eq r2 = rand(m2) .
  eq (pms(ss(p,dst(m2),p2,sid(m2))) = pms(a,b,s)) = false .
  eq pms(ss(p,dst(m2),p2,sid(m2))) = pms(dst(m2),p2,s) .
  eq dst(m2) = intruder .
  red inv6(p,a,b,r1,r2,c,i,s) implies
  inv6(sfin2(p,p2,m1,m2,m3),a,b,r1,r2,c,i,s) .
close
\end{verbatim}
\end{small}
The above proof passage corresponds to a (sub-) case obtained by splitting the induction case for \verb!sfin2!. CafeInMaude returns \verb!true! for the proof passage, however CiMPG can not generate the correct proof script for the equation 
% In each open-close fragment, several equations are added, and then the extended specifications (the original specification + the open-close fragment) often becomes non-confluent. Even so, CafeInMaude returns true and CiMPG can successfully generate correct proof spirits for the open-close fragment. You need to investigate that every non-confluent extended specification cannot be successfully handled by CiMPG or only some cannot. If this is the latter case, you need to investigate what type of non-confluent (what type of equations) cause errors by CiMPG.
% It is not enough to use a concrete example to explain it.
\verb!eq pms(ss(p,dst(m2),! \verb!p2, sid(m2))) = pms(a,b,s) .!
since we have the equation \verb!eq a = dst(m2) .! and \verb!a! rewrites to \verb!dst(m2)!, not vice versa. Hence, the equation should be \verb!eq pms(ss(p,dst(m2),! \verb!p2, sid(m2))) = pms(dst(m2),p2,s) .! Then we revise the proof fragment as follows:
\begin{small}
\begin{verbatim}
open INV .
  op p : -> Protocol .
  ops a b : -> Prin .
  ops r1 r2 : -> Rand .
  op c : -> Choice .
  op i : -> Sid .
  op s : -> Secret .
-- arbitrary objects
  op p2 : -> Prin .
  ops m1 m2 m3 : -> Msg .
-- assumptions
  eq m1 \in nw(p) = true .
  eq m2 \in nw(p) = true .
  eq m3 \in nw(p) = true .
  eq ch2?(m1) = true .
  eq sh2?(m2) = true .
  eq cf2?(m3) = true .
  eq crt(m2) = p2 .
  eq src(m2) = p2 .
  eq src(m1) = dst(m2) .
  eq dst(m1) = p2 .
  eq src(m3) = dst(m2) .
  eq dst(m3) = p2 .
  eq sid(m1) = sid(m2) .
  eq (ss(p,dst(m2),p2,sid(m2)) = none) = false .
  eq choice(ss(p,dst(m2),p2,sid(m2))) = choice(m2) .
  eq ecfin2(m3) = ecfin2(k(dst(m2),pms(ss(p,dst(m2),p2,
  sid(m2))),rand(m1),rand(m2)),cfin2(dst(m2),p2,sid(m2),
   choice(m2),rand(m1),rand(m2),pms(ss(p,dst(m2),p2,sid(m2))))) .
  eq r1 = rand(m1) .
  eq a = dst(m2) .
  eq i = sid(m2) .
  eq c = choice(m2) .
  eq b = p2 .
  eq r2 = rand(m2) .
  eq pms(ss(p,dst(m2),p2,sid(m2))) = pms(dst(m2),p2,s) .
  red inv6(p,a,b,r1,r2,c,i,s) implies
  inv6(sfin2(p,p2,m1,m2,m3),a,b,r1,r2,c,i,s) .
close
\end{verbatim}
\end{small}

Let us consider an another concrete example of the following two equations:
\begin{small}
\begin{verbatim}
eq a = b .
eq a = c .
\end{verbatim}
\end{small}
From the two equations, a, b and c are equal in equational logic point of view, however, \verb!a! rewrites to either \verb!b! or \verb!c! with rewriting.
CafeOBJ may rewrite \verb!a! to \verb!b!, while CafeInMaude may rewrite \verb!a! to \verb!c!. The behaviors of CafeOBJ and CafeInMaude are different if some
equations, such as a = b, are used in a module and some equations, such as a = c, are used in an open-close fragment that uses the module. Thus it is impossible to prove that all of a, b and c are equal only by rewriting when the specification (or term rewriting systems) is non-confluent.
If we revise the two equations as follows:
\begin{small}
\begin{verbatim}
eq a = b .
eq b = c .
\end{verbatim}
\end{small}
we can prove that all of a, b and c are equal only by rewriting. CafeOBJ, Maude and CafeInMaude do not use any completion techniques. Even if CafeOBJ and CafeInMaude return true for each open-close fragment of a proof
score, CiMPG may not correctly handle this kind of situation. This is because of the different behaviors of CafeOBJ and CafeInMaude. Rewriting is a sound implementation of equational reasoning but not a perfect implementation of equational reasoning. Therefore, we need to take care of this kind of situation when writing proof scores whose results depend on implementation, such as CafeOBJ, CafeInMaude and CiMPG.

In this section, we describe the cases that we encountered during revising proof scores and how to revise them based on CiMPG generated proof scripts. Taking a look at the following two equations corresponding to the induction case \verb!sfin! in \verb!7! below,
\begin{small}
\begin{verbatim}
eq pms(a,b,s) = pms(epms(m4)) .
eq a = dst(m2) .
\end{verbatim}
\end{small}
the first equation says that the left hand side rewrites the right hand side. The second equation says that \verb!a! rewrites \verb!dst(m2)!. When we declare the second equation, it does not rewrite \verb!a! into \verb!dst(m2)! in \verb!eq pms(a,b,s)!. Instead, the equation should be: \verb!eq pms(dst(m2),b,s) = pms(epms(m4)) .! There are many cases in which we need to revise the proof scores by changing the order of the equations if necessary.

The formal verification can be conducted by manually writing proof  scripts with CiMPA. However, writing proof scripts manually is not a good idea for this protocol because the size of the proof scores is large and it is subject to human errors. On the other hand, CiMPG takes time to generate the proof script when the size of the proof score is large. In this case study, we tackle each property with CiMPG one by one since the size of the proof score of some properties are quit complex and large. By conducting one invariant by one, it is easier to check the errors in the generated proof scripts and makes it understandable/guessable the cause of errors and then we can revise the proof scores in appropriate way. 

We use three devices (two MacBook Air that carry 1.6 GHz Intel Core i5 processor, 16 GB memory and one MacBook Pro that carries 2.3 GHz Quad-Core Intel Core i7 processor, 32 GB memory) to conduct this case study running the programs in parallel so as to complete the formal verification faster. CiMPG takes generally 8 to 9 hours to generate the proof scripts for each invariant in both devices, however it takes 52 hours and 17 minutes for running all inductive cases in one file for inv17 using MacBook Pro. Since the size of the proof scores of inv17 is quite large (it has 297 open–close proof fragments involving more than 8000 lines of code). We come up with an idea to divide the proof scores into smaller  open-close fragments when the proof scores is too big to be tackled by CiMPG so that CiMPG can generate the proof scripts from scores in a reasonable amount of time.

The proof scores of inv17 is divided into each induction case with the base case and feed into CiMPG using the same environment. Then, we measure the time taken for generating proof script for each induction case one by one and for all induction cases at the same time as shown in the table \ref{tab:tb3}. CiMPG takes 16 hours, 10 minutes and 58 seconds in total for all induction cases in inv17. The result obviously shows that CiMPG reduces the running time compared to running all induction cases in one time. Therefore, this is a good idea to divide the proof scores into smaller cases and running into CiMPG, however, we need to create 27 files to run each induction case separately.\\
\newline
\begin{table}[]
\caption{Runtime for each inductive case one by one Vs Runtime for all inductive cases at the same time for inv17}
\label{tab:tb3}
\begin{tabularx}{0.48\textwidth} { 
  | >{\centering\arraybackslash}X 
  | >{\centering\arraybackslash}X
  | >{\centering\arraybackslash}X
  | >{\centering\arraybackslash}X| }
 \hline
 inductive case & runtime (h:m:s) & inductive case & runtime (h:m:s) \\
 \hline
 cert & 0:01:30 & fakeKexch1 & 0:00:17 \\
 \hline
 cfin & 0:14:27 & fakeKexch2 & 0:00:26 \\
 \hline
 cfin2 & 0:03:15 & fakeSfin1 & 0:05:46 \\
 \hline
 chello & 0:00:22 & fakeSfin2 & 0:02:02 \\
 \hline
 chello2 & 0:00:01 & fakeSfin21 & 0:00:13 \\
 \hline
 compl & 0:53:55 & fakeSfin22 & 0:00:01 \\
 \hline
 compl2 & 0:19:18 & fakeShello & 0:11:09 \\
 \hline
 fakeCert & 0:21:02 & fakeShello2 & 0:00:01 \\
 \hline
 fakeCfin1 & 0:00:01 & kexch & 0:06:42 \\
 \hline
 fakeCfin2 & 0:00:14 & sfin & 13:41:00 \\
 \hline
 fakeCfin21 & 0:00:01 & sfin2 & 0:06:29 \\
 \hline
 fakeCfin22 & 0:00:08 & shello & 0:02:10 \\
 \hline
 fakeChello & 0:00:01 & shello2 & 0:00:26 \\
 \hline
 fakeChello2 & 0:00:01 & \textbf{Total time} & 16:10:58\\
 \hline
\end{tabularx}
% \caption{Runtime for each inductive case of inv17}
% \label{tab:tb3}
\end{table}

\begin{table}[]
\begin{tabularx}{0.48\textwidth} { 
  | >{\centering\arraybackslash}X 
  | >{\centering\arraybackslash}X|
 }
 \hline
 all in one & runtime (h:m:s) \\
 \hline
 inv17 & 52:17:18 \\
 \hline
\end{tabularx}
% \caption{Runtime for all inductive cases of inv17 in one file}
\end{table}

% Please add the time taken for tackling the while of inv17 so as to easily compare both time taken.
% You may have two tables in Table 3. If so, each table is give its own caption. The caption of Table 3 should be revised.

\subsection{how to revise the existing proof scores}
\subsection{how to find one missing lemma and the lemma}
\subsection{how to handle each proof score one by one with CiMPG}
\subsection{how to handle each induction case one by one with CiMPG}


\section{Related Work}\label{relatedwork}
From a CafeOBJ specification and an invariant property,
while CiMPG requires complete proof scores of the property to generate correct proof scripts,
CiMPG+F \cite{Riesco20}, which is another tool implemented on top of CafeInMaude,
can infer proof scripts even some proof score fragments are missing.
Precisely, CiMPG+F can (i) generate complete proof scripts from scratch and (ii) fix incomplete proof scores.
Human users need to introduce invariant properties to be proven and the variable on which structural induction is used.
When the proof scores provided are incomplete, CiMPG+F tries to fix it by using the given information to prune the search space.
Furthermore, when proof scripts cannot be generated from scratch, human users can provide a (partial) proof score guiding the process; in this way, CiMPG+F is in charge of the mechanical work and leaves human users the creative tasks.
The paper \cite{Riesco20} have reported experiments with several protocols, such as NSLPK, showing that CiMPG+F can completely generate proof scripts for all case studies.
TLS case study, whose formal specification is more complicated than all case studies used in the paper, is not tackled.

%The implementation of CiMPG+F employs some Maude meta-level functionalities, such as the built-in function \verb!metaReduce! to reduce a term to canonical form.
%An essential problem in the implementation of CiMPG+F is how to conduct case splitting.

There is a large number of tools existing for automatically verifying cryptographic protocols such as ProVerif \cite{proverif}, Maude-NPA \cite{maudenpa}, Tamarin \cite{tamarin}, and Scyther \cite{Scyther08}.
ProVerif can automatically prove security properties of cryptographic protocol specifications.
The tool is based on an abstract representation of the protocol by a set of Horn clauses,
and it determines whether the desired security properties hold by resolution on these clauses.
The practicability of ProVerif has been demonstrated through case studies in \cite{proverif2} and \cite{proverif3}. 
ProVerif can handle an unbounded number of sessions (executions) of protocols. 
% but termination is not guaranteed in general because the resolution algorithm may not terminate. 
However, the full automatic of ProVerif comes at a cost, that is, termination is not guaranteed in general because the resolution algorithm may not terminate. 
%the number of sessions (executions) of protocols may be unbounded. 

Maude-NPA \cite{maudenpa} is a tool for reasoning about the security of cryptographic protocols in which cryptosystems satisfy different equational properties.
The tool can handle searches in the unbounded session model, and thus can be used to provide proofs of security as well as to search for attacks.
The most challenging problem is how to deal with a huge or even infinite state space.
To mitigate this challenge, Escobar et al. \cite{maudenpa08} have proposed some techniques to reduce the size of the search space, such as generating formal grammars representing terms (states information) unreachable from initial states and using super lazy intruder to delay the generation of substitution instances as much as possible.
Even though, the termination of the tool is not always guaranteed.
% Many case studies have been presented to demonstrate the practicability of Maude-NPA, such as ...
%TODO: search for some case studies and add them here

Scyther \cite{Scyther08} is an another tool for security verification of cryptographic protocols.
Like ProVerif, Scyther also supports an unbounded number of sessions, but it supports only a fixed set of cryptographic primitives (symmetric and asymmetric encryption and signatures) and does not allow for user-specified equational theories.
Its successor, namely Tamarin prover \cite{tamarin} supports equational theories.
Moreover, Tamarin  provides the two ways of constructing proofs: fully automated mode and interactive mode. 
The tool may not terminate in the fully automated mode.
In the interactive mode, the tool allows users to provide lemmas that must be proved. 
Of course, finding suitable lemmas is an intellectual task, which is not novel in the field of formal verification.
% Some case studies on security analysis of cryptographic primitives and protocols with Tamarin are ...
%TODO: search for some case studies and add them here

Ogata and Futatsugi \cite{1437139} have formally verified TLS 1.0 handshake protocol  with the proof score approach \cite{OgataF03fmoods}.
As we have already mentioned, writing proof scores by hand is prone to human errors even though it is flexible to do so.
Paulson \cite{Paulson99} has also analyzed TLS 1.0 handshake protocol  with his inductive method \cite{Paulson98}.
The verification, which was tackled with the proof assistant Isabelle/HOL \cite{NipkowPW02}, also confirmed the security of the protocol.
On the other hand,
Bhargavan et al. \cite{BhargavanFCZ12} have claimed that using some formal specification languages to specify cryptographic protocols often lacks details.
Thus, they have verified detailed cryptographic implementation of TLS 1.0.
%They claimed that using some formal specification languages to specify cryptographic protocols often lacks details.
%They then proposed  to verify detailed protocol implementations and deployments.
Their verification method consists of selecting a part of the implementation and writing additional verification harness code that specifies the attacker model, the cryptographic
assumptions, and the target security properties, and then compiling their combination to ProVerif \cite{proverif}. 
An advantage of the approach is that we can easily re-verify the code after a revision (like regression testing) because the verification tool chain is automated.
The automation, however, comes at a cost: in some cases, especially with a complicated implementation,
the verifier may not terminate; in others, it may take a huge amount of memory.


% The paper ~\cite{spin} used the model checking method to formally verify security protocols using Spin model checker. The paper exampled NSPK protocol and DS protocol. The experimental results showed that
% the number of the protocol model states has been decreased
% by a wide margin, and the efficiency of protocol verification has been improved properly. The security protocol models mainly include the protocol
% instance model and the intruder model. It is described with Promela Model. The property of security protocols is described using LTL. An attack is found in each protocol. The difference between their method and our method is that we use OTS/CafeOBJ method to formalize the protocols as state machines. The Dolev-Yao intruder model is used in both methods. Furthermore, this paper only verified the authentication property of security protocols while we verified authentication and secrecy properties.

% Mitchell, et al.[7] use the model checker Mur [3] to
% check seven simple protocols derived from the SSL 3.0
% handshake protocol. The primal reason why they have analyzed
% the protocols is to identify the purpose of certain message
% fields (version number, nonce, etc.) in some steps of
% the protocol. The analysis starts with the simplest version of
% the handshake protocol from which some fields are omitted,
% and the fields are gradually added to the protocol. The first
% six protocols have been found badly flawed and the model
% checker has found many attacks. The model checker has
% been used to check the final protocol with two clients, one
% server, no more than two simultaneous open sessions per
% server and no more than one resumption per session, and no
% attacks have been discovered.

% Paulson[11] analyzes the TLS handshake protocol with
% his inductive method[10] that is supported by the proof assistant
% Isabelle/HOL[8]. In the protocol analyzed by Paulson,
% servers always sent their certificates to clients, the key exchange method considered is RSA, and clients optionally
% send their certificates and ClientKeyExchange messages to
% servers. In his model of the protocol, a malicious principal
% called the spy, which corresponds to the intruder in our
% model, is taken into account and it is supposed that any session
% key, if used, may end up in the hands of the spy, which
% is denoted by the rule Oops. One of the results of the analysis
% is that session resumption turns out to be safe even if the
% spy has obtained session keys from earlier sessions.

% Palombo, et al. \cite{Palombo2015ACS} have formally analyzed several examples of a particular class of cryptographic protocols (NSPK, DS, TMN, and DH) using three alternative tools. They used SPIN to analyze explicit state models written in Promela; symbolic models in the pi-calculus were verified using Proverif, and finally, we proved lemmas that show protocol insecurity using the theorem prover Coq. They have presented that choosing the right tool always implies a trade-off. It is generally easier to model a system using SPIN’s state representation than using the pi-calculus or
% logical inference rules. However, SPIN can only verify a bounded number of sessions and
% message space. Proverif verifies an unbounded number of sessions and message space at the cost of potentially not terminating or reporting false attacks. On the other hand, Coq theories with security proofs are not bounded and can
% represent an unrestricted symbolic attacker. They have shown that protocol insecurity can be
% proved in Coq. On the other hand, proof that demonstrates that the properties hold may be harder to construct. In comparison with our research, we proved lemmas that show protocol security using proof assistant CiMPA and proof generator CiMPG.

\section{Conclusion}\label{conclusion}
This paper has presented TLS 1.0 handshake protocol formal verification case study with the help of proof generator CiMPG and proof assistant CiMPA. We have described how to revise the existing proof scores in the OTS/CafeOBJ method with some examples and how to make the formal verification of the protocol successful. CiMPG often takes time to generate proof scripts when the size of input
proof scores is huge. On the other hand, writing manual proof scripts for CiMPA is not a good idea for this case study. We found out an effective way to solve this issue by dividing the proof scores into smaller sub-case. One piece of our future work is to formally verify other security protocols with CiMPG. (may need to put specific work)

% Numbered list
% Use the style of numbering in square brackets.
% If nothing is used, default style will be taken.
%\begin{enumerate}[a)]
%\item 
%\item 
%\item 
%\end{enumerate}  

% Unnumbered list
%\begin{itemize}
%\item 
%\item 
%\item 
%\end{itemize}  

% Description list
%\begin{description}
%\item[]
%\item[] 
%\item[] 
%\end{description}  

% Figure
% \begin{figure}[<options>]
% 	\centering
% 		\includegraphics[<options>]{}
% 	  \caption{}\label{fig1}
% \end{figure}


% \begin{table}[<options>]
% \caption{}\label{tbl1}
% \begin{tabular*}{\tblwidth}{@{}LL@{}}
% \toprule
%   \\ % Table header row
% \midrule
% \\
% \\
% \\
% \\
% \bottomrule
% \end{tabular*}
% \end{table}

% Uncomment and use as the case may be
%\begin{theorem} 
%\end{theorem}

% Uncomment and use as the case may be
%\begin{lemma} 
%\end{lemma}

%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

% There are several ideas/devices that should be used to make the formal
% verification successful.


% To print the credit authorship contribution details
% \printcredits

%% Loading bibliography style file
%\bibliographystyle{model1-num-names}
\bibliographystyle{cas-model2-names}

% Loading bibliography database
\bibliography{cas-refs}

% Biography
\bio{}
% Here goes the biography details.
\endbio

% \bio{pic1}
% % Here goes the biography details.
% \endbio

\end{document}

% 