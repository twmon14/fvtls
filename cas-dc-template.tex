%% 
%% Copyright 2019-2021 Elsevier Ltd
%% 
%% This file is part of the 'CAS Bundle'.
%% --------------------------------------
%% 
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%% 
%% The list of all files belonging to the 'CAS Bundle' is
%% given in the file `manifest.txt'.
%% 
%% Template article for cas-dc documentclass for 
%% double column output.

\documentclass[a4paper,fleqn]{cas-dc}

% If the frontmatter runs over more than one page
% use the longmktitle option.

%\documentclass[a4paper,fleqn,longmktitle]{cas-dc}

%\usepackage[numbers]{natbib}
%\usepackage[authoryear]{natbib}
\usepackage[authoryear,longnamesfirst]{natbib}

%%%Author macros
\def\tsc#1{\csdef{#1}{\textsc{\lowercase{#1}}\xspace}}
\tsc{WGM}
\tsc{QE}
%%%

% Uncomment and use as if needed
%\newtheorem{theorem}{Theorem}
%\newtheorem{lemma}[theorem]{Lemma}
%\newdefinition{rmk}{Remark}
%\newproof{pf}{Proof}
%\newproof{pot}{Proof of Theorem \ref{thm}}

\begin{document}
\let\WriteBookmarks\relax
\def\floatpagepagefraction{1}
\def\textpagefraction{.001}

% Short title
\shorttitle{Formal verification of TLS with CiMPG}    

% Short author
\shortauthors{Thet Wai Mon, Duong Dinh Tran and Kazuhiro Ogata}  

% Main title of the paper
\title [mode = title]{Formal verification of TLS with CiMPG}  

% Title footnote mark
% eg: \tnotemark[1]
\tnotemark[1] 

% Title footnote 1.
% eg: \tnotetext[1]{Title footnote text}
\tnotetext[1]{This work was partially supported by ...} 

% First author
%
% Options: Use if required
% eg: \author[1,3]{Author Name}[type=editor,
%       style=chinese,
%       auid=000,
%       bioid=1,
%       prefix=Sir,
%       orcid=0000-0000-0000-0000,
%       facebook=<facebook id>,
%       twitter=<twitter id>,
%       linkedin=<linkedin id>,
%       gplus=<gplus id>]

% \author[<aff no>]{<author name>}[<options>]
\author[1]{Thet Wai Mon}
% Corresponding author indication
% \cormark[<corr mark no>]

% Footnote of the first author
% \fnmark[<footnote mark no>]

% Email id of the first author
\ead{thetwaimon@jaist.ac.jp}

% URL of the first author
% \ead[url]{<URL>}

% Credit authorship
% eg: \credit{Conceptualization of this study, Methodology, Software}
\credit{<Credit authorship details>}

% Address/affiliation
\affiliation[1]{organization={School of Information Science, Japan Advanced Institute of Science and Technology (JAIST)},
            addressline={1-1 Asahidai }, 
            city={Nomi},
            postcode={923-1292}, 
            state={Ishikawa},
            country={Japan}}

\author[1]{Duong Dinh Tran}

% Footnote of the second author
% \fnmark[2]

% Email id of the second author
\ead{duongtd@jaist.ac.jp}

% URL of the second author
% \ead[url]{}

% Credit authorship
\credit{}

\author[1]{Kazuhiro Ogata}

% Footnote of the author
\fnmark[*]

% Email id of the author
\ead{ogata@jaist.ac.jp}

% Address/affiliation
% \affiliation[<aff no>]{organization={},
%             addressline={}, 
%             city={},
% %          citysep={}, % Uncomment if no comma needed between city and postcode
%             postcode={}, 
%             state={},
%             country={}}

% Corresponding author text
\cortext[1]{Corresponding author}

% Footnote text
\fntext[1]{}

% For a title note without a number/mark
%\nonumnote{}

% Here goes the abstract
\begin{abstract}
TLS protocol has been formally verified with CiMPG in CafeInMaude. The formal specification of TLS is modeled as transition systems in terms of equations in CafeOBJ/OTS method, and it has been verified that the system have properties by means of equational reasoning. The given initial proof scores in CafeOBJ are revised and added some additional proof fragments in some invariants if it is necessary such that the proof scores are complete and they could be successfully tackled by CiMPG. When the complete and correct proof scores are available, they are verified in CiMPG. Feeding the proof scores into CiMPG, CiMPG can generate proof scripts for CiMPA. However, it is not a good idea to feed all proof scores of all invariants in CiMPG as one file because CiMPG takes too much time to generate the proof scripts since the size of the proof score is quite large. Thus, each invariant has been tackled with CiMPG one by one.
\end{abstract}

% Use if graphical abstract is present
%\begin{graphicalabstract}
%\includegraphics{}
%\end{graphicalabstract}

% Research highlights
% \begin{highlights}
% \item 
% \item 
% \item 
% \end{highlights}

% Keywords
% Each keyword is seperated by \sep
\begin{keywords}
 CiMPG \ CafeInMaude \ invariant \ OTS \ proof scores
\end{keywords}

\maketitle

% Main text
\section{Introduction}\label{intro}
Internet security has become the important topic in recent years. The rapid development of e-commerce, individuals and organizations are relying on the Web and security services such as online banking, online shops etc, that need to exchange the sensitive information such as credit card numbers, account numbers, etc. between two parties in non-secure network environment. With the increase service availability the number of risks increase both for users and providers. In order to ensure a secure communication between them, a large number of security protocols have been designed and developed to protect the data. Among them, Transport Layer Security protocol (TLS) [\cite{dierk}] is the most widely used security protocol. TLS is the successor of Secure Sockets Layer (SSL) [\cite{1621007}]. 
% here

TLS was mainly developed in order to give the customers
confidence in their interactions when they access online services
from their electronic devices. If two parties want to securely establish a common key over an insecure channel, they typically execute a key exchange protocol. Both TLS and SSL protocols confine a set of rules for the communication between client and server. They rely on public-key cryptography in order to ensure integrity of exchanged data. Although  these  authentication  protocols  have been carefully designed by security experts, it is not uncommon for security attacks  as  technology  continues  to  advance. Despite multiple prevention measurements, several vulnerabilities such as  
Heartbleed [\cite{10.1145/2663716.2663755}] and DROWN [\cite{197245}] have been discovered. Therefore, ensuring the reliability of security protocols is really important and more effort is required to test the implementations of such security protocols.

One promising technology is formal verification  with theorem  proving. Theorem proving has been used to prove that systems enjoy some desired properties by writing proof scores. Proof scores are written as programs in an algebraic specification language to conduct formal verification. This approach uses observational transition systems (OTSs) [\cite{OgataF03fmoods}] as state machines to formalize systems. A security protocol,together with the most generic intruder, is modeled as an OTS. Then, the OTSs are specified in equations with CafeOBJ [\cite{DiaconescuF98amast}], a formal specification language. CafeOBJ implements equational logic by rewriting. System properties are expressed as CafeOBJ terms. Formal verification is conducted by writing what is called ``proof scores'' [\cite{OgataF03fmoods}] in CafeOBJ and executing them with CafeOBJ. This approach to formal verification is flexible, however, the proof may contain some flaws since proof scores are subject to human errors. 

CafeInMaude is the second implementation in Maude of CafeOBJ, where Maude [\cite{ClavelEtal2007maude}] is a sibling language of CafeOBJ.
CafeInMaude introduces CafeOBJ specifications into the Maude system.
It comes with two extension tools CafeInMaude Proof Assistant (CiMPA) and CafeInMaude Proof Generator (CiMPG) [\cite{RiescoO18tosem}]. CiMPA is a proof assistant that allows users to write proof scripts in order to prove invariant properties on their CafeOBJ specifications. Using CiMPA to develop the formal verification by writing proof scripts can help us to avoid the flaw made by human users. However, it is often the case that CiMPA is not flexible enough to conduct formal verification, especially when the size of proof score is huge. 

CiMPG allows users to combine the flexibility of the proof score approach and the reliability of CiMPA by providing a minimal set of annotations for identifying proof scores and generating CiMPA scripts for these proof scores. Given slightly annotated proof scores, CiMPG generates proof scripts for CiMPA. Feeding the generated proof scripts into CiMPA, if CiMPA successfully discharges all goals, the proof scores are correct for the goals and the formal verification is successful. Although CiMPG can automatically generate proof scripts for CiMPA from annotated proof scores, it will take time to do so when the size of the input proof score is large.

We have formally verified academic protocols
such as NSLPK authentication protocol [\cite{twmon}]. TLS protocol is much more complicated than academic protocols. Although it has been formally analyzed and verified that TLS enjoys some desired properties in [\cite{1437139}] with OTS/CafeOBJ method, we are the first to formally verify that TLS enjoys some desired properties with CiMPG as  well as CiMPA. 
All specifications and proofs presented in this paper are available at \url{https://github.com/twmon14/xxxx}.

The rest of the paper is organized as follows. Section \ref{tls} mentions TLS, TLS handshake protocol and the abstract handshake protocol. Section \ref{fstls} presents the formal specification of TLS. Section \ref{fvtls} describes the formal verification of TLS with CiMPG. Some related work is mentioned in Section \ref{relatedwork}. Finally, we give our conclusions and some lines of future work in Section \ref{conclusion}.
	
\section{TLS}\label{tls}
TLS [\cite{dierk}] provides privacy and data integrity between client/server communications. The protocol consists of four sub-protocols. They are TLS handshake protocol, the change cipher spec protocol, the alert protocol and TLS record protocol. 

When two peers want to establish a communication, TLS handshake protocol is used to negotiate a cipher suite and security parameters between client and server. The change cipher spec protocol is used when each of two peers(client/server) want to notify the other that subsequent messages after handshake process will be protected under the newly negotiated cipher suite,  and security parameters. If either of them notices something wrong, one lets the other know about it with the alert protocol. TLS record protocol provides private and reliable communications between the two peers using the negotiated cipher suite and security parameters.

If a cipher suite used is weaker than the available one to both peers or the security parameters shared by both peers are leaked by some reasons, then an adequate level of security cannot be obtained. Therefore, the security of TLS largely depends on a cipher suite and security parameter negotiated by client/ server in handshake process. It can be said that among four sub-protocols, TLS handshake protocol takes part in the most important role and the security of TLS relies on TLS handshake protocol. 

\subsection{TLS handshake protocol}\label{handshake}
Figure 1 shows the message exchanges between client and server in TLS handshake protocol. 

To initiate a new run of the protocol, a server may send a HelloRequest message to a client or a client sends a ClientHello message to the server. On receipt of the HelloRequest message from server, the client replies to server with a ClientHello message. A ClientHello message contains the basic information such as a version number of TLS, a list of cipher suites that are available to the client, a random number generated by client, etc.

The server then replies to the ClientHello message with a
ServerHello message, which consists of a version number of TLS that is lower than the one suggested by the client and the highest supported by the server, a session ID, a cipher suite chosen from the list suggested by the client in the ClientHello message, a random number generated by server, etc. 

If the server should be authenticated, the server sends  his/her certificate to the client. If the server Certificate message does not contain enough data to allow the client to exchange a parameter secret called a pre-master secret, the server sends a ServerKeyExchange message to the client. The server can optionally request a certificate from the client by sending a CertificateRequest message. The server sends a ServerHelloDone message to the client to indicate the end of the ServerHello.

When the client receives ServerHelloDone message, the client checks the messages received. When it is necessary, the client sends his/her certificate to the server. If it is sent, then a ClientKeyExchange message is always sent by the client after the client Certificate message. Otherwise, the ClientKeyExchange message is the first message sent by the client after he/she receives a ServerHelloDone message. The ClientKeyExchange message
contains a pre-master secret which is a random number generated by the client. Two key exchange methods (RSA and Diffie-Hellman) are specified to exchange a pre-master secret. 

After ClientKeyExchange message, the client can optionally send a CertificateVerify message to explicitly provide a verification of the client certificate.
The client notifies the server with the change cipher spec protocol that subsequent messages will be protected under the newly negotiated cipher suite and security parameters. The client then sends a Finished message to the server to verify that the handshake process
is finished successfully. The Finished message is protected under the just negotiated cipher suite and security parameters.

On receipt of the client Finished message, the server
checks the message received. If the message is correct, the server notifies the client with the change cipher spec protocol that subsequent messages will be protected under the newly negotiated cipher suite and security parameters. The server then sends a server Finished message to the client to verify that the handshake process is successful.

On receipt of the server Finished message, the client
checks the message received. If the message is correct, the handshake process is done successfully between client and server and the client can exchange application data securely with server in the current session.

A previously established session and a current session
can be resumed and/or duplicated without exchanging all handshake messages. If a client wants to resume or duplicate a session, he/she sets the session ID in a new ClientHello message and sends it to a server. The ClientHello message is protected under the current cipher suite and security parameters. On receipt of the ClientHello message, if the server wants to resume or duplicate the session, he/she replies to the client with a new ServerHello message. The ServerHello message is protected under the current cipher suite and security parameters. 

The server then signals the client to use the newly negotiated security parameters for the session. The same cipher suite is used. A server Finished message is then sent to the client by the server. On receipt of the server Finished message, the client checks the message received. If the message is correct, the client signals the server to use the newly negotiated security parameters for the session and a client Finished message is then sent to the server. On receipt of the client Finished message, the server checks the message. If the message is correct, the session is then resumed and/or duplicated and the client can exchange application data securely with server in that session.

\subsection{The Abstract Handshake Protocol}\label{abstracthandshake}
Figure 2 shows the abstract version of TLS handshake protocol. In the protocol, A denotes a client and B a server respectively. In the figure, the first six exchanged messages are the full handshake process in which a cipher suite and security parameters are negotiated between client and server. The remaining ones are for the resumption of a previously established session or the duplication of a current session.

Cryptographic functions used in the protocol are H(.)
(a one-way hash function), $\varepsilon_K(.)$ (an encryption function with symmetric or asymmetric key $K$) and $S_X(.)$(a digital signature function with principal $X$’s private key). The other primitives used in the protocol are Rand$_X$ (a random number generated by principal $X$), ListOfChoices (a list of cipher suites), Choice (a cipher suite), SID (a session ID), PMS (a pre-master secret), CA (certificate authority) and K$_X$ (principal $X$'s public key).

Composite data occurring in the protocol are as follows:
Cert$_X$ : $X$, K$_X$, $S_{CA}$($X$, K$_X$) \newline
ClientKey : H(A, PMS, Rand$_A$, Rand$_B$) \newline
ClientKey : H(B, PMS, Rand$_A$, Rand$_B$) \newline
ClientFinish : H("client", $A$, $B$, SID, ListOfChoices, Choice, Rand$_A$, Rand$_B$, PMS)\newline
ServerFinish : H("server", $A$, $B$, SID, ListOfChoices, Choice, Rand$_A$, Rand$_B$, PMS)\newline
ClientFinish2 : H("client", $A$, $B$, SID, Choice, Rand$_A$, Rand$_B$, PMS)\newline
ServerFinish2 : H("server", $A$, $B$, SID, Choice, Rand$_A$, Rand$_B$, PMS)\newline

We suppose the following in the abstract handshake protocol: a server always sends his/her certificate to a client when a full handshake process is performed; a server sends neither SeverKeyExchange nor CertificateRequest messages; server Certificate message also plays the role of ServerHelloDone messages; a client sends neither Certificate nor CertificateVerify messages; ChangeCipherSpec messages are implicit; there exists only one trusted certificate authority; the method used for exchanging pre-master secrets is RSA only; the content of Finished messages is not the hash of the security parameters and handshake messages exchanged, but that of two random numbers and a pre-master secret, etc.
% 		\end{verbatim}
% 	\end{small}

\section{Formal Specification of TLS} \label{fstls}
Suppose that there exist not only multiple trustable
principals but also multiple malicious (untrustable) principals, and the cryptosystem used is perfect. Trustable
principals exactly follow the protocol, while malicious ones may do something against the protocol as well. The combination and cooperation of malicious principals is modeled as the most general intruder Dolev-Yao [\cite{dolev}]. 
An intruder can glean as much information as possible from messages flowing in the network and create fake messages based on the gleaned information, provided that the intruder cannot break the perfect cryptosystem.

We specify 10 operators (data construtors) to define 10 kinds of messages. The data constructors used in TLS are declared as follows:
\begin{small}
		\begin{verbatim}
op ch  : Prin    Prin   Prin  Rand ListOfChoices -> Msg
op sh  : Prin    Prin   Prin  Rand Sid Choice    -> Msg
op ct  : Prin    Prin   Prin  Cert               -> Msg
op kx  : Prin    Prin   Prin  EncPms             -> Msg
op cf  : Prin    Prin   Prin  EncCFin            -> Msg
op sf  : Prin    Prin   Prin  EncSFin            -> Msg
op ch2 : Prin    Prin   Prin  Rand Sid           -> Msg
op sh2 : Prin    Prin   Prin  Rand Sid Choice    -> Msg
op cf2 : Prin    Prin   Prin  EncCFin2           -> Msg
op sf2 : Prin    Prin   Prin  EncSFin2           -> Msg
		\end{verbatim}
	\end{small}
where \verb!Msg! is the sort denoting messages. 

The other sorts and the corresponding data
constructors that constitute the messages are declared as follows:
\begin{itemize}
  \item \verb!Principal! denotes principals. There are two special principals; one is the \verb!intruder! denoted by intruder and the other the certificate authority denoted by \verb!ca!. We suppose that \verb!intruder! does not equal \verb!ca!. 
  \item \verb!Rand! denotes random numbers generated by principals.
\item \verb!ListOfChoices! denotes lists of cipher suites. Operator \verb|_\in_| is the membership predicate of lists.
  \item \verb!Choice! denotes cipher suites. 
  \item \verb!Sid! denotes session IDs. 
  \item \verb!PubKey! denotes public keys. The principal $a$’s public key is denoted by \verb!k!($a$).
\item \verb!Sig! denotes digital signatures of pairs of a principal and a public key. The digital signature of the pair of principal $b$ and public key $k$ signed by $ca$ is denoted by \verb!sig!($ca$, $b$, $k$).
\item \verb!Cert! denotes certificates of public keys. Given principal $a$, public key $k$ and signature $g$, the certificate that $k$ is $a$’s,
which is certified by $g$, is denoted by \verb!cert!($a$, $k$, $g$).
\item \verb!Secret! denotes secret values that make pre-master secret globally unique and unguessable. 
\item \verb!Pms! denotes premaster secrets. Given two principals $a,b$ and a secret value $s$, a pre-master secret generated by client $a$ for server $b$ is denoted by \verb!pms!($a$, $b$, $s$).
\item \verb!Key! denotes hashes used as symmetric keys to encrypt Finished messages. Given principal $a$, pre-master secret $pms$ and two random numbers $r1,r2$, the hash of those quantities is denoted by \verb!k!($a$, $pms$, $r1, r2$).
\item \verb!CFinish! denotes ClientFinish’s. Given two principals $a, b$, session ID $i$, list $l$ of cipher suites, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ClientFinish is denoted by \verb!cfin!($a, b$, $i$, $l$, $c$, $r1, r2$, $s$).
\item \verb!SFinish! denotes ServerFinish’s. Given two principals $a, b$, session ID $i$, list $l$ of cipher suites, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ServerFinish is denoted by \verb!sfin!($a, b$, $i$, $l$, $c$, $r1, r2$, $s$).
\item \verb!CFinish2! denotes ClientFinish2’s. Given two principals $a, b$, session ID $i$, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ClientFinish is denoted by \verb!cfin2!($a, b$, $i$, $c$, $r1, r2$, $s$).
\item \verb!SFinish2! denotes ServerFinish2’s. Given two principals $a, b$, session ID $i$, cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $s$, the corresponding ServerFinish is denoted by \verb!sfin2!($a, b$, $i$, $c$, $r1, r2$, $s$).
\item \verb!EncPms! denotes pre-master secrets encrypted by public keys. Pre-master secret $pms$ encrypted by public key $k$ is denoted by \verb!epms!($k$, $pms$).
\item \verb!EncCFin! denotes ClientFinish’s encrypted by symmetric keys. ClientFinish $f$ encrypted by symmetric key $k$ denoted by \verb!ecfin!($k$, $f$).
\item \verb!EncSFin! denotes ServerFinish’s encrypted by symmetric keys. ServerFinish $f$ encrypted by symmetric key $k$ denoted by \verb!esfin!($k$, $f$).
\item \verb!EncCFin2! denotes ClientFinish2’s encrypted by symmetric keys. ClientFinish2 $f$ encrypted by symmetric key $k$ denoted by \verb!ecfin2!($k$, $f$).
\item \verb!EncSFin2! denotes ServerFinish2’s encrypted by symmetric keys. ServerFinish2 $f$ encrypted by symmetric key $k$ denoted by \verb!esfin2!($k$, $f$).
\item \verb!Session! denotes a quadruple of a cipher suite, two random numbers and a pre-master secret. A quadruple of cipher suite $c$, two random numbers $r1, r2$ and pre-master secret $pms$ is denoted by \verb!st!($c$, $r1, r2$, $pms$).
\end{itemize}

For each data constructor such as \verb!pms!, \verb!sig!, etc., projection operators such as \verb!client!, \verb!server! and \verb!secret! that return arguments of the data constructor are also defined. For example, \verb!client(pms!($a$, $b$, $s$)) = $a$, \verb!server(pms!($a$, $b$, $s$)) = $b$ and \verb!secret(pms!($a$, $b$, $s$)) = $s$. Other projection operators for other data constructor are also defined likewise.

For data constructor \verb!x! (where \verb!x = ch!, \verb!sh!, \verb!ct!, \verb!kx!, \verb!cf!, \verb!sf!, \verb!ch2,! \verb!sh2!, \verb!sf2!, \verb!cf2!), predicate \verb!x!? is defined, which checks if a given message is \verb!x! message. Given a term denoting a message, projection operators such as \verb!crt!, \verb!src! and \verb!dst! return the first, second and third arguments of the term, respectively.The first, second and  third  arguments  of  each  message are  the  actual creator,  the  seeming  sender  and  the  receiver  of the  corresponding message. The first argument is meta-information that is only available to the outside observer and the principal that has sent the corresponding message, and that cannot be forged by the intruder; while the remaining arguments may be forged by the intruder. The projection operators \verb!rand, list, choice, sid, cert, epms, ecfin, esfin, ecfin2! and \verb!esfin2! return other arguments, respectively.

Suppose that there exists a message in the network. It is true that the principal denoted by the first
argument has sent the message. If the first argument is the
intruder and the second one is not, then the message has been
faked by the intruder. For example, a principal $a$ receives a message denoted by \verb!ct!($b$',$b$,$a$,$cert$). 
Since messages are supposed to be never deleted from the network, if there exists a message denoted by
\verb!ct!($b$,$b$,$a$,$cert$) the network, we can conclude that the message received by $a$ really originates from $b$.
Therefore, this formalization of messages makes it possible to describe a property such as one that a message received by a principal really originates from the seeming sender (second argument) of the message. 

The  network  is  modeled  as  a  multiset  of  messages,  in which the intruder can use as his/her storage. Any message that has been sent or put once into the network is supposed to be never deleted from the network because the intruder can replay the message repeatedly, although the intruder cannot forge the first argument. Consequently, the empty network(i.e., the empty multiset) means that no messages have been sent.

The intruder tries to glean seven kinds of quantities from
the network as much as possible. The seven kinds of quantities are pre-master secrets, digital signatures and five kinds of ciphertexts. The collections of the seven quantities gleaned by the intruder from the network are denoted by the following operators, respectively:
\begin{small}
\begin{verbatim}
op cpms : Network -> ColPms
op csig : Network -> ColSig
op cepms : Network -> ColEncPms
op cecfin : Network -> ColEncCFin
op cesfin : Network -> ColEncSFin
op cecfin2 : Network -> ColEncCFin2
op cesfin2 : Network -> ColEncSFin2
\end{verbatim}
\end{small}	
where Network is the sort denoting networks. Col$X$ is
the sort denoting collections of quantities denoted
by sort $X$.

The operators are defined with equations. For example, the operator \verb!cpms! is defined with equations as follows:
\begin{small}
\begin{verbatim}
eq PMS \in cpms(void) = (client(PMS) = intruder) .
ceq PMS \in cpms(M,NW) = true if (kx?(M) and
owner(k(epms(M))) = intruder and PMS = pms(epms(M))) .
ceq PMS \in cpms(M,NW) = PMS \in cpms(NW) if not(kx?(M) and
owner(k(epms(M))) = intruder and PMS = pms(epms(M))) .
\end{verbatim}
\end{small}	
where constant \verb!void! denotes the empty bag. Operator    \verb|_,_| of \verb!M,NW! is the data constructor of bags. The first equation says that any pre-master secret generated by the intruder is always available to the intruder and no other pre-master secrets are at any initial state. Messages from which pre-master secrets can be gleaned are Certificate messages only. The second equation says that if there exits a Certificate message in the network and the ciphertext in the message is encrypted with the intruder’s public key, then the pre-master secret in the message can be available to the intruder. The third one says that no pre-master secrets cannot be gleaned from any non-Certificate messages and any Certificate messages whose ciphertexts are not encrypted with the intruder’s public key. The remaining operators are also defined likewise.

We declare five observational functions respectively as follows:
\begin{small}
\begin{verbatim}
op nw : Protocol -> Network
op ss : Protocol Prin Prin Sid -> Session
op ur : Protocol -> URand
op ui : Protocol -> USid
op us : Protocol -> USecret
\end{verbatim}
\end{small}	
where \verb!Protocol! is  the  sort  denoting  the  state  space. \verb!URand!, \verb!USid! and \verb!USecret! are the  sorts denoting sets of random numbers, ones of session IDs and ones of secrets. 

Let $p$ denote a state of the protocol. \verb!nw!($p$) denotes the network, \verb!ur!($p$) the set of used random numbers, \verb!ui!($p$) that of used session IDs and \verb!us!($p$) that of used secrets in the state. 
\verb!ss!($p$, $a$, $b$, $i$) denotes the principal $a$’s session state identified by session ID $i$ with principal $b$ in the state where $a, b$ denotes principals and $i$ a session ID.

We define 27 transitions together with one constant of \verb!Protocol! to represent an arbitrary initial state.
The behavior of trustable principals is modeled by 12
kinds of transitions. 10 of them correspond to sending
the 10 kinds of messages. The remaining two correspond
to clients’ receiving ServerFinished messages and
servers’ receiving ClientFinished2 messages, respectively.
The 12 kinds of transitions are denoted by the following operators:
\begin{small}
\begin{verbatim}
op chello : Protocol Prin Prin Rand ListOfChoices ->
Protocol {constr}
op shello : Protocol Prin Rand Sid Choice Msg -> Protocol {constr}
op cert : Protocol Prin Msg Msg -> Protocol {constr}
op kexch : Protocol Prin Secret Msg Msg Msg -> Protocol {constr}
op cfin : Protocol Prin Secret Msg Msg Msg Msg -> Protocol {constr}
op sfin : Protocol Prin Msg Msg Msg Msg Msg -> Protocol {constr}
op compl : Protocol Prin Secret Msg Msg Msg Msg Msg Msg ->
Protocol {constr}
op chello2 : Protocol Prin Prin Secret Rand Sid -> 
Protocol {constr}
op shello2 : Protocol Prin Rand Msg -> Protocol {constr}
op cfin2 : Protocol Prin Secret Msg Msg -> Protocol {constr}
op sfin2 : Protocol Prin Msg Msg Msg -> Protocol {constr}
op compl2 : Protocol Prin Secret Msg Msg Msg Msg -> 
Protocol {constr} 
\end{verbatim}
\end{small}	

The 12 action operators are defined with equations. In
this paper, we show the equations for \verb!chello!, which are declared as follows:
\begin{small}
\begin{verbatim}
op c-chello : Protocol Prin Prin Rand ListOfChoices -> Bool
eq c-chello(P,A,B,R,L) = not(R \in ur(P)) .
ceq nw(chello(P,A,B,R,L)) = ch(A,A,B,R,L) , nw(P) 
if c-chello(P,A,B,R,L) .
eq  ss(chello(P,A,B,R,L),A2,B2,I2) = ss(P,A2,B2,I2) .
ceq ur(chello(P,A,B,R,L)) = R ur(P) if c-chello(P,A,B,R,L) .
eq  ui(chello(P,A,B,R,L)) = ui(P) .
eq  us(chello(P,A,B,R,L)) = us(P) .
ceq chello(P,A,B,R,L)     = P if not c-chello(P,A,B,R,L) . 
\end{verbatim}
\end{small}	
The  equations  say  that  if c-chello(P,A,B,R,L) is  true
(i.e., random number R has   not   been   used), then the ClientHello message ch(A,A,B,R,L) is put into the network nw(P), R is put into ur(P); if c-chello(P,A,B,R,L) is  false,  nothing  changes.  The remaining transitions can be defined likewise.

The behavior of the intruder is modeled by 15
kinds of transitions. The intruder fakes messages based on the gleaned information. The effective condition to the action operators is that the necessary information is available to the intruder. The 15 kinds of transitions are defined by the following operators:
\begin{small}
\begin{verbatim}
op fakeChello : Protocol Prin Prin Rand ListOfChoices ->
Protocol {constr}
op fakeShello : Protocol Prin Prin Rand Sid Choice ->
Protocol {constr}
op fakeCert : Protocol Prin Prin PubKey Sig -> Protocol {constr}
op fakeKexch1 : Protocol Prin Prin EncPms -> Protocol {constr}
op fakeKexch2 : Protocol Prin Prin PubKey Pms -> Protocol {constr}
op fakeCfin1 : Protocol Prin Prin EncCFin -> Protocol {constr}
op fakeCfin2 : Protocol Prin Prin Sid ListOfChoices Choice Rand 
Rand Pms -> Protocol {constr}
op fakeSfin1 : Protocol Prin Prin EncSFin -> Protocol {constr}
op fakeSfin2 : Protocol Prin Prin Sid ListOfChoices Choice Rand 
Rand Pms -> Protocol {constr}
op fakeChello2 : Protocol Prin Prin Rand Sid -> Protocol {constr}
op fakeShello2 : Protocol Prin Prin Rand Sid Choice ->
Protocol {constr}
op fakeCfin21  : Protocol Prin Prin EncCFin2 -> Protocol {constr}
op fakeCfin22  : Protocol Prin Prin Sid Choice Rand Rand Pms -> 
Protocol {constr}
op fakeSfin21  : Protocol Prin Prin EncSFin2 -> Protocol {constr}
op fakeSfin22  : Protocol Prin Prin Sid Choice Rand Rand Pms -> 
Protocol {constr} 
\end{verbatim}
\end{small}	
Each operator is defined with equations. In the original specification of TLS, the state space is denoted by hidden sort and the action and observation operators with respect to hidden sorts are declared by starting with \verb !bop!. 
We slightly revise the original specification of the state space denoting visible sort and the action and observation operators are declared with respect to visible sorts by starting with \verb !op! as behavioral specifications are not supported in CafeInMaude.

\section{Formal Verification of TLS with CiMPG}\label{fvtls}
The five properties for the protocol [\cite{1437139}] are formalized as CafeOBJ terms. To formally verify the five properties, 13 more properties are required. Let us define the properties as inv$x$ where x = 1 to 18. inv1, inv3, inv5, inv17 and inv18 are the five properties of the protocol. The first property is formalized as follows: 
\begin{small}
\begin{verbatim}
eq inv1(P,PMS) = (PMS \in cpms(nw(P)) implies 
(client(PMS) = intruder or server(PMS) = intruder)) .
\end{verbatim}
\end{small}
The equation says that if a pre-master secret is available to the intruder, the pre-master secret has been generated by the intruder or a client has generated it for a session with the intruder. This implies that the intruder cannot obtain any pre-master secrets for sessions in which the intruder is not involved. Other properties can be understood likewise.

Among 18 properties, five of the properties specifically inv12, inv13, inv16, inv17 and inv18 have been proved by case analyses with other properties, and the remaining ones by induction on the number of transitions applied in the original proof scores. Our purpose is to formally verify the properties with CiMPG. However,  to  make  it  possible  for  CiMPG  to  generate  the proof scripts correctly, the existing proof scores need to be modified so that they can be run successfully in CafeInMaude environment. While we revise the given initial proof scores, there are many cases in which we need to conduct the case splitting by introducing equations and/or use other properties as lemma to strengthen the inductive hypothesis many times. Besides, we revise/write the proof scores for five properties by induction on the number of transitions applying some tips on writing proof scores in the CafeOBJ method [\cite{Ogata2006}].

If all proof scores are reduced to true when executed then the corresponding theorems are proved. If they are not directly reduced to true, so case splitting is required. After case splittings, they can be reduced to true. If all proof scores are complete, now we are ready to use CiMPG to formally verified the properties. To use CiMPG, we slightly need to annotate the proof scores. Let us use one example of proof score open-close fragment that is annotated to use CiMPG. The following proof fragment is one case of inv13
\begin{small}
\begin{verbatim}
open INV .
  :id(tls)
  op p : -> Protocol .
  ops a b b1 : -> Prin .
  ops r1 r2 : -> Rand .
  op l : -> ListOfChoices .
  op c : -> Choice .
  op i : -> Sid .
  op s : -> Secret .
  op k : -> PubKey .
-- arbitrary objects
  ops p1 p2 : -> Prin .
  op esfin1 : -> EncSFin .
-- assumptions
  eq esfin1 \in cesfin(nw(p)) = true .
  eq esfin1 = esfin(k(b,pms(a,b,s),r1,r2),
  sfin(a,b,i,l,c,r1,r2,pms(a,b,s))) .
  eq a = intruder .
  eq a = p1 .
  eq b = intruder .
  eq b = p2 .
  eq b1 = intruder . 
  red inv13(p,a,b,b1,r1,r2,l,c,i,s,k) implies
  inv13(fakeSfin1(p,p2,p1,esfin1),a,b,b1,r1,r2,l,c,i,s,k) .
close
\end{verbatim}
\end{small}
where all the constants except for intruder denote arbitrary
values of the intended sorts. For example, a, b, b1, p1 and p2 denote arbitrary values of sort Prin. Moreover, we need to add one more open-close fragment to the proof scores, which is as follows:
\begin{small}
\begin{verbatim}
open INV
  :proof(tls)
close
\end{verbatim}
\end{small}
where \verb!tls! is just an identifier, can be replaced by another one that is more preferred. Feeding the annotated proof scores into CiMPG, CiMPG automatically generates the proof script for CiMPA.

Before feeding the generated proof scripts into CiMPA, we need to check whether the generated proof scripts contain the errors since there is a situation that CiMPG can not generate proof scripts correctly when the proof scores are not correct. CiMPG generates a formal proof script when the proof score was correct and complete. We describe some examples on how to revise the proof scores so as to generate the correct proof scripts from proof scores by CiMPG. As an example, by the time we run the above proof score fragment with CiMPG, the generated proof script contains the errors indicating that the proof score is not correct. We then need to carefully take a look at the proof score and revise it accordingly by the indicated errors. Note that CiMPG points out the flaws in other case, but it could not suggest how to fix them. We remove some equations in the above proof passage and it can be reduced to true. The revised one for the above proof fragment is as follows:
\begin{small}
\begin{verbatim}
open INV .
  :id(tls)
  op p : -> Protocol .
  ops a b b1 : -> Prin .
  ops r1 r2 : -> Rand .
  op l : -> ListOfChoices .
  op c : -> Choice .
  op i : -> Sid .
  op s : -> Secret .
  op k : -> PubKey .
-- arbitrary objects
  ops p1 p2 : -> Prin .
  op esfin1 : -> EncSFin .
-- assumptions
  eq esfin1 \in cesfin(nw(p)) = true .
  eq esfin1 = esfin(k(b,pms(a,b,s),r1,r2),
  sfin(a,b,i,l,c,r1,r2,pms(a,b,s))) .
  eq a = intruder .
red inv13(p,a,b,b1,r1,r2,l,c,i,s,k) implies
inv13(fakeSfin1(p,p2,p1,esfin1),a,b,b1,r1,r2,l,c,i,s,k) .
close
\end{verbatim}
\end{small}
The annotated proof scores are fed into CiMPG again, CiMPG  generates the proof script for CiMPA. Unfortunately, there is an error in the scripts that remind us the proof score is still not good enough for CiMPG to generate the proof script. Then we remove the last equation and feed the proof score into CiMPG. The revised proof score is as follows:
\begin{small}
\begin{verbatim}
open INV .
  :id(tls)
  op p : -> Protocol .
  ops a b b1 : -> Prin .
  ops r1 r2 : -> Rand .
  op l : -> ListOfChoices .
  op c : -> Choice .
  op i : -> Sid .
  op s : -> Secret .
  op k : -> PubKey .
-- arbitrary objects
  ops p1 p2 : -> Prin .
  op esfin1 : -> EncSFin .
-- assumptions
  eq esfin1 \in cesfin(nw(p)) = true .
  eq esfin1 = esfin(k(b,pms(a,b,s),r1,r2),
  sfin(a,b,i,l,c,r1,r2,pms(a,b,s))) .
red inv13(p,a,b,b1,r1,r2,l,c,i,s,k) implies
inv13(fakeSfin1(p,p2,p1,esfin1),a,b,b1,r1,r2,l,c,i,s,k) .
close
\end{verbatim}
\end{small}
CiMPG could generate the correct proof scripts for CiMPA this time. Although writing proof scores is flexible to conduct formal verification, the verification may contain some flaws because proof scores are subject to human errors. Human users can overlook some cases during the proof because several case splittings are in general possible for each goal. While conducting formal verification with CiMPG can guarantee the reliability even though it is quite strict to tackle. From this example, we learn the less that we do not need to introduce the equations unnecessarily even though CafeInMaude returns true for this proof passage. 

Let us consider the following proof passage corresponding to case sfin2 of inv6:
\begin{small}
\begin{verbatim}
open INV .
  op p : -> Protocol .
  ops a b : -> Prin .
  ops r1 r2 : -> Rand .
  op c : -> Choice .
  op i : -> Sid .
  op s : -> Secret .
-- arbitrary objects
  op p2 : -> Prin .
  ops m1 m2 m3 : -> Msg .
-- assumptions
  eq m1 \in nw(p) = true .
  eq m2 \in nw(p) = true .
  eq m3 \in nw(p) = true .
  eq ch2?(m1) = true .
  eq sh2?(m2) = true .
  eq cf2?(m3) = true .
  eq crt(m2) = p2 .
  eq src(m2) = p2 .
  eq src(m1) = dst(m2) .
  eq dst(m1) = p2 .
  eq src(m3) = dst(m2) .
  eq dst(m3) = p2 .
  eq sid(m1) = sid(m2) .
  eq (ss(p,dst(m2),p2,sid(m2)) = none) = false .
  eq choice(ss(p,dst(m2),p2,sid(m2))) = choice(m2) .
  eq ecfin2(m3) = ecfin2(k(dst(m2),pms(ss(p,dst(m2),p2,
  sid(m2))),rand(m1),rand(m2)),cfin2(dst(m2),p2,sid(m2),
   choice(m2),rand(m1),rand(m2),pms(ss(p,dst(m2),p2,sid(m2))))) .
  eq r1 = rand(m1) .
  eq a = dst(m2) .
  eq i = sid(m2) .
  eq c = choice(m2) .
  eq b = p2 .
  eq r2 = rand(m2) .
  eq (pms(ss(p,dst(m2),p2,sid(m2))) = pms(a,b,s)) = false . -- (23)
  eq pms(ss(p,dst(m2),p2,sid(m2))) = pms(dst(m2),p2,s) . -- (24)
  eq dst(m2) = intruder . -- (25)
  red inv6(p,a,b,r1,r2,c,i,s) implies
  inv6(sfin2(p,p2,m1,m2,m3),a,b,r1,r2,c,i,s) .
close
\end{verbatim}
\end{small}
The proof passage corresponds to a (sub-) case obtained by splitting the induction case for \verb!sfin2!. CafeInMaude returns \verb!true! for the proof passage, however CiMPG can not generate the correct proof script for the equation 
\verb!eq pms(ss(p,dst(m2),p2, sid(m2))) = pms(a,b,s) .!
since we have the equation \verb!eq a = dst(m2) .! and \verb!a! rewrites to \verb!dst(m2)!, not vice versa. Hence, the equation should be \verb!eq pms(ss(p,dst(m2),p2, sid(m2))) = pms(dst(m2),p2,s) .! Then we revise the proof fragment using (24) by removing two equations (23) and (25).

Let us consider an another concrete example of the following two equations:
\begin{small}
\begin{verbatim}
eq a = b .
eq a = c .
\end{verbatim}
\end{small}
From the two equations, a, b and c are equal in equational logic point of view, however, \verb!a! rewrites to either \verb!b! or \verb!c! with rewriting.
CafeOBJ may rewrite \verb!a! to \verb!b!, while CafeInMaude may rewrite \verb!a! to \verb!c!. The behaviors of CafeOBJ and CafeInMaude are different if some
equations, such as a = b, are used in a module and some equations, such as a = c, are used in an open-close fragment that uses the module. Thus it is impossible to prove that all of a, b and c are equal only by rewriting when the specification (or term rewriting systems) is non-confluent.
If we revise the two equations as follows:
\begin{small}
\begin{verbatim}
eq a = b .
eq b = c .
\end{verbatim}
\end{small}
we can prove that all of a, b and c are equal only by rewriting. CafeOBJ, Maude and CafeInMaude do not use any completion techniques. Even if CafeOBJ and CafeInMaude return true for each open-close fragment of a proof
score, CiMPG may not correctly handle this kind of situation. This is because of the different behaviors of CafeOBJ and CafeInMaude. Rewriting is a sound implementation of equational reasoning but not a perfect implementation of equational reasoning. Therefore, we need to take care of this kind of situation when writing proof scores whose results depend on implementation, such as CafeOBJ, CafeInMaude and CiMPG.

In this section, we describe the cases that we encountered during revising proof scores and how we revise them based on CiMPG generated result. Taking a look at the following two equations corresponding to the induction case \verb!sfin! in \verb!7! as follows:
\begin{small}
\begin{verbatim}
eq pms(a,b,s) = pms(epms(m4)) .
eq a = dst(m2) .
\end{verbatim}
\end{small}
the first equation says that the left hand side rewrites the right hand side. The second equation says that \verb!a! rewrites \verb!dst(m2)!. When we declare the second equation , it does not rewrite \verb!a! into \verb!dst(m2)! in the first equation. Hence, \verb!eq pms(a,b,s) = pms(epms(m4))! does not make sense. Instead, the equation should be: \verb!eq pms(dst(m2),b,s) = pms(epms(m4)) .! There are many cases in which we need to revise the proof scores by changing the order of the equations if necessary.

The formal verification can be conducted by writing  proof  scripts  with  CiMPA. However, writing proof scripts manually is not a good idea for this protocol because the size of the proof scores is large and it is subject to human errors. On the other hand, CiMPG takes time to generate the proof script when the size of the proof score is large. In this case study, we tackle each property with
CiMPG one by one since the size of the proof score of each property is quit complex and large. By conducting one invariant by one, we can understand the problems and revise the proof scores in appropriate way. 

We use three devices (two MacBook Air that carry 1.6 GHz Intel Core i5 processor, 16 GB memory and one MacBook Pro that carries 2.3 GHz Quad-Core Intel Core i7 processor, 32 GB memory) to run the programs in parallel so as to complete the formal verification faster. CiMPG takes 8~9 hours to generate the proof scripts for each invariant in both devices, however it takes 52 hours and 17 minutes for inv17 using MacBook Pro. Since the size of the proof scores of inv17 is quite large (it has 297 open–close proof fragments involving more than 8000 lines of code). We come up with an idea to divide the proof scores into smaller  open-close fragments when the proof scores is too big to be tackled by CiMPG in a reasonable amount of time.

The proof scores of inv17 is divided into each induction case with the base case and feed into CiMPG using the same environment. Then, we measure the time for each induction case. CiMPG takes 28 hours and 3 minutes in total for all induction cases. The result is obvious that CiMPG reduces the running time. Therefore, this is a good idea to divide the proof scores into smaller cases and running into CiMPG, however, we need to create 27 files to run each induction case separately. 


\section{Related Work}\label{relatedwork}
% The paper ~\cite{spin} used the model checking method to formally verify security protocols using Spin model checker. The paper exampled NSPK protocol and DS protocol. The experimental results showed that
% the number of the protocol model states has been decreased
% by a wide margin, and the efficiency of protocol verification has been improved properly. The security protocol models mainly include the protocol
% instance model and the intruder model. It is described with Promela Model. The property of security protocols is described using LTL. An attack is found in each protocol. The difference between their method and our method is that we use OTS/CafeOBJ method to formalize the protocols as state machines. The Dolev-Yao intruder model is used in both methods. Furthermore, this paper only verified the authentication property of security protocols while we verified authentication and secrecy properties.

% Mitchell, et al.[7] use the model checker Mur [3] to
% check seven simple protocols derived from the SSL 3.0
% handshake protocol. The primal reason why they have analyzed
% the protocols is to identify the purpose of certain message
% fields (version number, nonce, etc.) in some steps of
% the protocol. The analysis starts with the simplest version of
% the handshake protocol from which some fields are omitted,
% and the fields are gradually added to the protocol. The first
% six protocols have been found badly flawed and the model
% checker has found many attacks. The model checker has
% been used to check the final protocol with two clients, one
% server, no more than two simultaneous open sessions per
% server and no more than one resumption per session, and no
% attacks have been discovered.

% Paulson[11] analyzes the TLS handshake protocol with
% his inductive method[10] that is supported by the proof assistant
% Isabelle/HOL[8]. In the protocol analyzed by Paulson,
% servers always sent their certificates to clients, the key exchange method considered is RSA, and clients optionally
% send their certificates and ClientKeyExchange messages to
% servers. In his model of the protocol, a malicious principal
% called the spy, which corresponds to the intruder in our
% model, is taken into account and it is supposed that any session
% key, if used, may end up in the hands of the spy, which
% is denoted by the rule Oops. One of the results of the analysis
% is that session resumption turns out to be safe even if the
% spy has obtained session keys from earlier sessions.

% Palombo, et al. \cite{Palombo2015ACS} have formally analyzed several examples of a particular class of cryptographic protocols (NSPK, DS, TMN, and DH) using three alternative tools. They used SPIN to analyze explicit state models written in Promela; symbolic models in the pi-calculus were verified using Proverif, and finally, we proved lemmas that show protocol insecurity using the theorem prover Coq. They have presented that choosing the right tool always implies a trade-off. It is generally easier to model a system using SPIN’s state representation than using the pi-calculus or
% logical inference rules. However, SPIN can only verify a bounded number of sessions and
% message space. Proverif verifies an unbounded number of sessions and message space at the cost of potentially not terminating or reporting false attacks. On the other hand, Coq theories with security proofs are not bounded and can
% represent an unrestricted symbolic attacker. They have shown that protocol insecurity can be
% proved in Coq. On the other hand, proof that demonstrates that the properties hold may be harder to construct. In comparison with our research, we proved lemmas that show protocol security using proof assistant CiMPA and proof generator CiMPG.

\section{Conclusion}\label{conclusion}
We have described how to revise the proof scores of TLS v1.0 in the OTS/CafeOBJ method to succeed the formal verification of the protocol with CiMPG. CiMPG often takes time to generate proof scripts when the size of input
proof scores is big. We found an effective solution for this issue by dividing the proof scores into smaller sub-case.







% Numbered list
% Use the style of numbering in square brackets.
% If nothing is used, default style will be taken.
%\begin{enumerate}[a)]
%\item 
%\item 
%\item 
%\end{enumerate}  

% Unnumbered list
%\begin{itemize}
%\item 
%\item 
%\item 
%\end{itemize}  

% Description list
%\begin{description}
%\item[]
%\item[] 
%\item[] 
%\end{description}  

% Figure
% \begin{figure}[<options>]
% 	\centering
% 		\includegraphics[<options>]{}
% 	  \caption{}\label{fig1}
% \end{figure}


% \begin{table}[<options>]
% \caption{}\label{tbl1}
% \begin{tabular*}{\tblwidth}{@{}LL@{}}
% \toprule
%   &  \\ % Table header row
% \midrule
%  & \\
%  & \\
%  & \\
%  & \\
% \bottomrule
% \end{tabular*}
% \end{table}

% Uncomment and use as the case may be
%\begin{theorem} 
%\end{theorem}

% Uncomment and use as the case may be
%\begin{lemma} 
%\end{lemma}

%% The Appendices part is started with the command \appendix;
%% appendix sections are then done as normal sections
%% \appendix

% There are several ideas/devices that should be used to make the formal
% verification successful.


% To print the credit authorship contribution details
\printcredits

%% Loading bibliography style file
%\bibliographystyle{model1-num-names}
\bibliographystyle{cas-model2-names}

% Loading bibliography database
\bibliography{cas-refs}

% Biography
\bio{}
% Here goes the biography details.
\endbio

% \bio{pic1}
% % Here goes the biography details.
% \endbio

\end{document}

% 